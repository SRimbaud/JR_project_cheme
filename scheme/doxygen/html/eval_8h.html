<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Livrable1 Informatique Phelma SICOM: Référence du fichier include/eval.h</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Livrable1 Informatique Phelma SICOM
   </div>
   <div id="projectbrief">Interpréteur Scheme</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Généré par Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Recherche');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Recherche');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#typedef-members">Définitions de type</a> &#124;
<a href="#func-members">Fonctions</a>  </div>
  <div class="headertitle">
<div class="title">Référence du fichier eval.h</div>  </div>
</div><!--header-->
<div class="contents">

<p>Evaluation stuff for SFS.  
<a href="#details">Plus de détails...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="primitive_8h_source.html">primitive.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Graphe des dépendances par inclusion de eval.h:</div>
<div class="dyncontent">
<div class="center"><img src="eval_8h__incl.png" border="0" usemap="#include_2eval_8h" alt=""/></div>
<!-- MAP 0 -->
</div>
</div><div class="textblock"><div class="dynheader">
Ce graphe montre quels fichiers incluent directement ou indirectement ce fichier :</div>
<div class="dyncontent">
<div class="center"><img src="eval_8h__dep__incl.png" border="0" usemap="#include_2eval_8hdep" alt=""/></div>
<!-- MAP 1 -->
</div>
</div>
<p><a href="eval_8h_source.html">Aller au code source de ce fichier.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Définitions de type</h2></td></tr>
<tr class="memitem:af581f8cc2bba3b54da9fd9d7225cb1f2"><td class="memItemLeft" align="right" valign="top"><a id="af581f8cc2bba3b54da9fd9d7225cb1f2"></a>
typedef struct <a class="el" href="structobject__t.html">object_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>object</b></td></tr>
<tr class="separator:af581f8cc2bba3b54da9fd9d7225cb1f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Fonctions</h2></td></tr>
<tr class="memitem:ae380eb697aba625d9557508c5ce78230"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structobject__t.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="eval_8h.html#ae380eb697aba625d9557508c5ce78230">sfs_eval</a> (<a class="el" href="structobject__t.html">object</a> input, <a class="el" href="structobject__t.html">object</a> <a class="el" href="repl_8c.html#a062b7366fcc9f920dbb8475d815e0bfc">env</a>)</td></tr>
<tr class="memdesc:ae380eb697aba625d9557508c5ce78230"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fonction d'évaluation d'expression scheme.  <a href="#ae380eb697aba625d9557508c5ce78230">Plus de détails...</a><br /></td></tr>
<tr class="separator:ae380eb697aba625d9557508c5ce78230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a1f129c513c24456d85a102835bd32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structobject__t.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="eval_8h.html#ae6a1f129c513c24456d85a102835bd32">sfs_eval_compound</a> (<a class="el" href="structobject__t.html">object</a> pair)</td></tr>
<tr class="memdesc:ae6a1f129c513c24456d85a102835bd32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evalue un agrégat.  : L'entrée de l'utilisateur dont le symbole est évalué.  : L'environnement dans lequel on est.  <a href="#ae6a1f129c513c24456d85a102835bd32">Plus de détails...</a><br /></td></tr>
<tr class="separator:ae6a1f129c513c24456d85a102835bd32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fa12a03242edab3d6319587d2cbf59a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structobject__t.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="eval_8h.html#a4fa12a03242edab3d6319587d2cbf59a">EVAL_quote</a> (<a class="el" href="structobject__t.html">object</a> o, <a class="el" href="structobject__t.html">object</a> <a class="el" href="repl_8c.html#a062b7366fcc9f920dbb8475d815e0bfc">env</a>)</td></tr>
<tr class="memdesc:a4fa12a03242edab3d6319587d2cbf59a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evalue l'expression quote.  <a href="#a4fa12a03242edab3d6319587d2cbf59a">Plus de détails...</a><br /></td></tr>
<tr class="separator:a4fa12a03242edab3d6319587d2cbf59a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a019ed7c50b864c42ea880ac81aec0048"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structobject__t.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="eval_8h.html#a019ed7c50b864c42ea880ac81aec0048">EVAL_define</a> (<a class="el" href="structobject__t.html">object</a> o, <a class="el" href="structobject__t.html">object</a> <a class="el" href="repl_8c.html#a062b7366fcc9f920dbb8475d815e0bfc">env</a>)</td></tr>
<tr class="memdesc:a019ed7c50b864c42ea880ac81aec0048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evalue un define.  <a href="#a019ed7c50b864c42ea880ac81aec0048">Plus de détails...</a><br /></td></tr>
<tr class="separator:a019ed7c50b864c42ea880ac81aec0048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a721bfb9ef69a26cf3ae3784d46e4e620"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structobject__t.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="eval_8h.html#a721bfb9ef69a26cf3ae3784d46e4e620">EVAL_set</a> (<a class="el" href="structobject__t.html">object</a> o, <a class="el" href="structobject__t.html">object</a> <a class="el" href="repl_8c.html#a062b7366fcc9f920dbb8475d815e0bfc">env</a>)</td></tr>
<tr class="memdesc:a721bfb9ef69a26cf3ae3784d46e4e620"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mets à jour une variable.  <a href="#a721bfb9ef69a26cf3ae3784d46e4e620">Plus de détails...</a><br /></td></tr>
<tr class="separator:a721bfb9ef69a26cf3ae3784d46e4e620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac2cfb148bd205981b2b064910faf3a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structobject__t.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="eval_8h.html#aac2cfb148bd205981b2b064910faf3a6">EVAL_and</a> (<a class="el" href="structobject__t.html">object</a> o, <a class="el" href="structobject__t.html">object</a> <a class="el" href="repl_8c.html#a062b7366fcc9f920dbb8475d815e0bfc">env</a>)</td></tr>
<tr class="memdesc:aac2cfb148bd205981b2b064910faf3a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne un et logique de o.  <a href="#aac2cfb148bd205981b2b064910faf3a6">Plus de détails...</a><br /></td></tr>
<tr class="separator:aac2cfb148bd205981b2b064910faf3a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ca142d5d9bdbf2d494608d6700010c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structobject__t.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="eval_8h.html#a8ca142d5d9bdbf2d494608d6700010c8">EVAL_or</a> (<a class="el" href="structobject__t.html">object</a> o, <a class="el" href="structobject__t.html">object</a> <a class="el" href="repl_8c.html#a062b7366fcc9f920dbb8475d815e0bfc">env</a>)</td></tr>
<tr class="memdesc:a8ca142d5d9bdbf2d494608d6700010c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation de la forme or.  <a href="#a8ca142d5d9bdbf2d494608d6700010c8">Plus de détails...</a><br /></td></tr>
<tr class="separator:a8ca142d5d9bdbf2d494608d6700010c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a714a5266b28df03925d36547221130e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structobject__t.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="eval_8h.html#a714a5266b28df03925d36547221130e3">EVAL_if</a> (<a class="el" href="structobject__t.html">object</a> o, <a class="el" href="structobject__t.html">object</a> <a class="el" href="repl_8c.html#a062b7366fcc9f920dbb8475d815e0bfc">env</a>)</td></tr>
<tr class="memdesc:a714a5266b28df03925d36547221130e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evalue un if.  <a href="#a714a5266b28df03925d36547221130e3">Plus de détails...</a><br /></td></tr>
<tr class="separator:a714a5266b28df03925d36547221130e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b626fbe83d75afeb2c6183f35bd90bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structobject__t.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="eval_8h.html#a6b626fbe83d75afeb2c6183f35bd90bc">EVAL_begin</a> (<a class="el" href="structobject__t.html">object</a> o, <a class="el" href="structobject__t.html">object</a> <a class="el" href="repl_8c.html#a062b7366fcc9f920dbb8475d815e0bfc">env</a>)</td></tr>
<tr class="memdesc:a6b626fbe83d75afeb2c6183f35bd90bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evalue la forme begin.  <a href="#a6b626fbe83d75afeb2c6183f35bd90bc">Plus de détails...</a><br /></td></tr>
<tr class="separator:a6b626fbe83d75afeb2c6183f35bd90bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4e01ebbfbff53c2221b64ce542d5703"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structobject__t.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="eval_8h.html#af4e01ebbfbff53c2221b64ce542d5703">EVAL_lambda</a> (<a class="el" href="structobject__t.html">object</a> o, <a class="el" href="structobject__t.html">object</a> <a class="el" href="repl_8c.html#a062b7366fcc9f920dbb8475d815e0bfc">env</a>)</td></tr>
<tr class="memdesc:af4e01ebbfbff53c2221b64ce542d5703"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evalue lambda et créer l'objet de type compound correspondant.  <a href="#af4e01ebbfbff53c2221b64ce542d5703">Plus de détails...</a><br /></td></tr>
<tr class="separator:af4e01ebbfbff53c2221b64ce542d5703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a742e61207e511c960890af404ad64d97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structobject__t.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="eval_8h.html#a742e61207e511c960890af404ad64d97">EVAL_let</a> (<a class="el" href="structobject__t.html">object</a> o, <a class="el" href="structobject__t.html">object</a> <a class="el" href="repl_8c.html#a062b7366fcc9f920dbb8475d815e0bfc">env</a>)</td></tr>
<tr class="memdesc:a742e61207e511c960890af404ad64d97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evalue la forme let.  <a href="#a742e61207e511c960890af404ad64d97">Plus de détails...</a><br /></td></tr>
<tr class="separator:a742e61207e511c960890af404ad64d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0059ac2d5fc1abec50561b5b9a1b494e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structobject__t.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="eval_8h.html#a0059ac2d5fc1abec50561b5b9a1b494e">IF_predicat</a> (<a class="el" href="structobject__t.html">object</a> input)</td></tr>
<tr class="memdesc:a0059ac2d5fc1abec50561b5b9a1b494e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne le prédicat d'une structure if.  <a href="#a0059ac2d5fc1abec50561b5b9a1b494e">Plus de détails...</a><br /></td></tr>
<tr class="separator:a0059ac2d5fc1abec50561b5b9a1b494e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2d724e0225104a8dcd621f5f691c601"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structobject__t.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="eval_8h.html#ae2d724e0225104a8dcd621f5f691c601">IF_consequence</a> (<a class="el" href="structobject__t.html">object</a> input)</td></tr>
<tr class="memdesc:ae2d724e0225104a8dcd621f5f691c601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renvoie la conséquence d'une structure if.  <a href="#ae2d724e0225104a8dcd621f5f691c601">Plus de détails...</a><br /></td></tr>
<tr class="separator:ae2d724e0225104a8dcd621f5f691c601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefec57e38712b1baf88ee81276fe57ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structobject__t.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="eval_8h.html#aefec57e38712b1baf88ee81276fe57ed">IF_alternative</a> (<a class="el" href="structobject__t.html">object</a> input)</td></tr>
<tr class="memdesc:aefec57e38712b1baf88ee81276fe57ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne l'alternative d'une structure if.  <a href="#aefec57e38712b1baf88ee81276fe57ed">Plus de détails...</a><br /></td></tr>
<tr class="separator:aefec57e38712b1baf88ee81276fe57ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a026bb47409acef4341f840fc817b292c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structobject__t.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="eval_8h.html#a026bb47409acef4341f840fc817b292c">IF_overargument</a> (<a class="el" href="structobject__t.html">object</a> input)</td></tr>
<tr class="memdesc:a026bb47409acef4341f840fc817b292c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vérifie que if n'ait pas un argument en trop.  <a href="#a026bb47409acef4341f840fc817b292c">Plus de détails...</a><br /></td></tr>
<tr class="separator:a026bb47409acef4341f840fc817b292c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05993cb29ab0fc9204e80695ce39a4c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structobject__t.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="eval_8h.html#a05993cb29ab0fc9204e80695ce39a4c2">LAMBDA_get_var</a> (<a class="el" href="structobject__t.html">object</a> input)</td></tr>
<tr class="memdesc:a05993cb29ab0fc9204e80695ce39a4c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renvoie le nom des variables d'une forme lambda.  <a href="#a05993cb29ab0fc9204e80695ce39a4c2">Plus de détails...</a><br /></td></tr>
<tr class="separator:a05993cb29ab0fc9204e80695ce39a4c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab23dd5520e0d7fcaec96318ff9b52d1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structobject__t.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="eval_8h.html#ab23dd5520e0d7fcaec96318ff9b52d1c">LAMBDA_get_body</a> (<a class="el" href="structobject__t.html">object</a> input)</td></tr>
<tr class="memdesc:ab23dd5520e0d7fcaec96318ff9b52d1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renvoie les instructions d'un lambda.  <a href="#ab23dd5520e0d7fcaec96318ff9b52d1c">Plus de détails...</a><br /></td></tr>
<tr class="separator:ab23dd5520e0d7fcaec96318ff9b52d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d5c4441d55f4188c8bf913120643eb4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="eval_8h.html#a2d5c4441d55f4188c8bf913120643eb4">LAMBDA_check_number_arg</a> (<a class="el" href="structobject__t.html">object</a> input)</td></tr>
<tr class="memdesc:a2d5c4441d55f4188c8bf913120643eb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vérifie que lambda ait bien le bon nombre d'arguments.  <a href="#a2d5c4441d55f4188c8bf913120643eb4">Plus de détails...</a><br /></td></tr>
<tr class="separator:a2d5c4441d55f4188c8bf913120643eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae625530b96120d1101e6332938c8d580"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structobject__t.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="eval_8h.html#ae625530b96120d1101e6332938c8d580">LET_eval</a> (<a class="el" href="structobject__t.html">object</a> input, <a class="el" href="structobject__t.html">object</a> <a class="el" href="repl_8c.html#a062b7366fcc9f920dbb8475d815e0bfc">env</a>)</td></tr>
<tr class="memdesc:ae625530b96120d1101e6332938c8d580"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evalue le corps d'un let dans l'environnement env.  <a href="#ae625530b96120d1101e6332938c8d580">Plus de détails...</a><br /></td></tr>
<tr class="separator:ae625530b96120d1101e6332938c8d580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0f95ddf7f8793c2333e1ff0acdb74d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="eval_8h.html#aae0f95ddf7f8793c2333e1ff0acdb74d">LET_check</a> (<a class="el" href="structobject__t.html">object</a> input)</td></tr>
<tr class="memdesc:aae0f95ddf7f8793c2333e1ff0acdb74d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vérifie que input possède bien la structure minimale de let.  <a href="#aae0f95ddf7f8793c2333e1ff0acdb74d">Plus de détails...</a><br /></td></tr>
<tr class="separator:aae0f95ddf7f8793c2333e1ff0acdb74d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Description détaillée</h2>
<div class="textblock"><p>Evaluation stuff for SFS. </p>
<dl class="section author"><dt>Auteur</dt><dd>François Cayre &lt;cayre.(null)&gt; </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Fri Jun 22 20:10:38 2012 Evaluation stuff for SFS. </dd></dl>
</div><h2 class="groupheader">Documentation des fonctions</h2>
<a id="aac2cfb148bd205981b2b064910faf3a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac2cfb148bd205981b2b064910faf3a6">&sect;&nbsp;</a></span>EVAL_and()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structobject__t.html">object</a> EVAL_and </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne un et logique de o. </p>
<p>On évalue chaque terme si on croise un terme faux on s'arrête et on retourne faux. Les termes sont évalués. Si le terme évalué n'est pas un booléen on le renvoie et on quitte la fonction. Si and est vide renvoie vrai par défaut. En cas de succession de termes non booléen, seul le dernier est affiché. Un terme non booléen est considéré comme vrai, s'il est le dernier dans le and, il est retourné. (fonctionnement de scheme48)</p>
<p>Renvoie NULL et affiche un warning en cas de problème.</p>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie le résultat. Renvoie un booléen ! </dd></dl>

</div>
</div>
<a id="a6b626fbe83d75afeb2c6183f35bd90bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b626fbe83d75afeb2c6183f35bd90bc">&sect;&nbsp;</a></span>EVAL_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structobject__t.html">object</a> EVAL_begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evalue la forme begin. </p>
<p>Evalue la forme begin : Chaque instruction de la forme est évaluée, l'évaluation de la dernière instruction est retournée. Prend en paramètre l'intégralité d'une instruction begin ex : (begin (define a 4) (+ a 34) )</p>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie l'évaluation de la dernière instruction. </dd></dl>

</div>
</div>
<a id="a019ed7c50b864c42ea880ac81aec0048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a019ed7c50b864c42ea880ac81aec0048">&sect;&nbsp;</a></span>EVAL_define()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structobject__t.html">object</a> EVAL_define </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evalue un define. </p>
<p>Prend en paramètre une instruction complète d'une entrée define. Evalue un define. évalue également de cddr. Effectue également la création dans l'environnement courant de la variable. Retourne le nom de la variable créée c'est à dire le symbole. Si le format de la chaine n'est pas bon elle retourne NULL et affiche un warning.</p>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie le symbole crée. </dd></dl>

</div>
</div>
<a id="a714a5266b28df03925d36547221130e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a714a5266b28df03925d36547221130e3">&sect;&nbsp;</a></span>EVAL_if()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structobject__t.html">object</a> EVAL_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evalue un if. </p>
<p>Si le prédicat est vrai renvoie la conséquence.<br />
S'il n'y a pas de prédicat retourne NULL et affiche des warnings. Sinon renvoie l'alternative. S'il n'y a pas d'alternative retourne #f. S'il n'y a pas de conséquence retourne retourne NULL et affiche une erreur. S'il y a trop d'arguments renvoie null et affiche un warning.</p>
<dl class="section see"><dt>Voir également</dt><dd><a class="el" href="eval_8c.html#ae2d724e0225104a8dcd621f5f691c601" title="Renvoie la conséquence d&#39;une structure if. ">IF_consequence</a> </dd>
<dd>
<a class="el" href="eval_8c.html#aefec57e38712b1baf88ee81276fe57ed" title="Retourne l&#39;alternative d&#39;une structure if. ">IF_alternative</a> </dd>
<dd>
<a class="el" href="eval_8c.html#a0059ac2d5fc1abec50561b5b9a1b494e" title="Retourne le prédicat d&#39;une structure if. ">IF_predicat</a> </dd>
<dd>
<a class="el" href="eval_8c.html#a026bb47409acef4341f840fc817b292c" title="Vérifie que if n&#39;ait pas un argument en trop. ">IF_overargument</a></dd></dl>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie l'évaluation d'un if. </dd></dl>

</div>
</div>
<a id="af4e01ebbfbff53c2221b64ce542d5703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4e01ebbfbff53c2221b64ce542d5703">&sect;&nbsp;</a></span>EVAL_lambda()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structobject__t.html">object</a> EVAL_lambda </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evalue lambda et créer l'objet de type compound correspondant. </p>
<p>Prend en entrée la ligne entrée par l'utilisateur.</p>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie un agrégat. </dd></dl>

</div>
</div>
<a id="a742e61207e511c960890af404ad64d97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a742e61207e511c960890af404ad64d97">&sect;&nbsp;</a></span>EVAL_let()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structobject__t.html">object</a> EVAL_let </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evalue la forme let. </p>
<p>Renvoie NULL si erreur. Appel de LET_check. Création d'un environnement dont env est le père. Appel de LET_eval si celui-ci.</p>
<dl class="section see"><dt>Voir également</dt><dd><a class="el" href="eval_8c.html#ae625530b96120d1101e6332938c8d580" title="Evalue le corps d&#39;un let dans l&#39;environnement env. ">LET_eval</a> </dd>
<dd>
<a class="el" href="eval_8c.html#aae0f95ddf7f8793c2333e1ff0acdb74d" title="Vérifie que input possède bien la structure minimale de let. ">LET_check</a></dd></dl>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie evaluation de let. </dd></dl>

</div>
</div>
<a id="a8ca142d5d9bdbf2d494608d6700010c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ca142d5d9bdbf2d494608d6700010c8">&sect;&nbsp;</a></span>EVAL_or()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structobject__t.html">object</a> EVAL_or </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluation de la forme or. </p>
<p>On évalue chaque terme du or tant qu'on a pas de terme vrai. Comme pour and si un terme n'est pas un booléen il est considéré comme vrai et on le retourne Si c'est le dernier, on le retourne (scheme48) or seul vaut faux par défaut.</p>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie un booléen qui correspond à un ou logique. </dd></dl>

</div>
</div>
<a id="a4fa12a03242edab3d6319587d2cbf59a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fa12a03242edab3d6319587d2cbf59a">&sect;&nbsp;</a></span>EVAL_quote()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structobject__t.html">object</a> EVAL_quote </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evalue l'expression quote. </p>
<p>Concrètement retourne le cdr de o.</p>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie le cdr de o. </dd></dl>

</div>
</div>
<a id="a721bfb9ef69a26cf3ae3784d46e4e620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a721bfb9ef69a26cf3ae3784d46e4e620">&sect;&nbsp;</a></span>EVAL_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structobject__t.html">object</a> EVAL_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mets à jour une variable. </p>
<p>set! est de la forme : (set! x &lt;valeur&gt;) x le symbole à mettre à jour et &lt;valeur&gt; sa nouvelle valeur. Renvoie x. Si x n'existe affiche un warning et retourne NULL. Si x n'est pas un symbole affiche un warning et retourne null. Si &lt;valeur&gt; est NULL affiche un warning et retourne NULL</p>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie le nom de la variable modifiée. </dd></dl>

</div>
</div>
<a id="aefec57e38712b1baf88ee81276fe57ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefec57e38712b1baf88ee81276fe57ed">&sect;&nbsp;</a></span>IF_alternative()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structobject__t.html">object</a> IF_alternative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne l'alternative d'une structure if. </p>
<p>Renvoie le cadddr. </p><dl class="section see"><dt>Voir également</dt><dd><a class="el" href="object_8c.html#a486b361de0c6c18f7227158b12dbfd4a" title="Renvoie de l&#39;élement de la pair correspondant à la chaine. ">OBJECT_get_cxr</a>(input, "cadddr")</dd></dl>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie l'alternative (le cadddr) </dd></dl>

</div>
</div>
<a id="ae2d724e0225104a8dcd621f5f691c601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2d724e0225104a8dcd621f5f691c601">&sect;&nbsp;</a></span>IF_consequence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structobject__t.html">object</a> IF_consequence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renvoie la conséquence d'une structure if. </p>
<p>Renvoie le caddr. </p><dl class="section see"><dt>Voir également</dt><dd><a class="el" href="object_8c.html#a486b361de0c6c18f7227158b12dbfd4a" title="Renvoie de l&#39;élement de la pair correspondant à la chaine. ">OBJECT_get_cxr</a></dd></dl>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie la conséquence (le caddr). </dd></dl>

</div>
</div>
<a id="a026bb47409acef4341f840fc817b292c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a026bb47409acef4341f840fc817b292c">&sect;&nbsp;</a></span>IF_overargument()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structobject__t.html">object</a> IF_overargument </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vérifie que if n'ait pas un argument en trop. </p>
<p>Renvoie nil si if contient le bon nombre d'argument ce nil provient de la construction normale du if que l'on obtient en allant chercher le cddddr (ce qui suit le prédicat</p>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie nil si if est bon, autre chose sinon. </dd></dl>

</div>
</div>
<a id="a0059ac2d5fc1abec50561b5b9a1b494e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0059ac2d5fc1abec50561b5b9a1b494e">&sect;&nbsp;</a></span>IF_predicat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structobject__t.html">object</a> IF_predicat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne le prédicat d'une structure if. </p>
<p>Revient à prendre le cadr. </p><dl class="section see"><dt>Voir également</dt><dd><a class="el" href="object_8c.html#a486b361de0c6c18f7227158b12dbfd4a" title="Renvoie de l&#39;élement de la pair correspondant à la chaine. ">OBJECT_get_cxr</a></dd></dl>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie l'alternative (le cadr). </dd></dl>

</div>
</div>
<a id="a2d5c4441d55f4188c8bf913120643eb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d5c4441d55f4188c8bf913120643eb4">&sect;&nbsp;</a></span>LAMBDA_check_number_arg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LAMBDA_check_number_arg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vérifie que lambda ait bien le bon nombre d'arguments. </p>
<p>Au minimum lambda possède aucun arguments et un body qui est réduit à un atome. Prend la ligne entrée par l'utilisateur (lambda ...)</p>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie 1 si le nombre d'arguments est correct 0 sinon. </dd></dl>

</div>
</div>
<a id="ab23dd5520e0d7fcaec96318ff9b52d1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab23dd5520e0d7fcaec96318ff9b52d1c">&sect;&nbsp;</a></span>LAMBDA_get_body()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structobject__t.html">object</a> LAMBDA_get_body </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renvoie les instructions d'un lambda. </p>
<p>Prend en argument l'instruction lambda complète.</p>
<dl class="section return"><dt>Renvoie</dt><dd>renvoie la liste des instructions du body </dd></dl>

</div>
</div>
<a id="a05993cb29ab0fc9204e80695ce39a4c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05993cb29ab0fc9204e80695ce39a4c2">&sect;&nbsp;</a></span>LAMBDA_get_var()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structobject__t.html">object</a> LAMBDA_get_var </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renvoie le nom des variables d'une forme lambda. </p>
<p>Prend en paramètre la liste qui doit être évaluée à lambda ex : (lambda (x y) (corps))</p>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie une liste de noms de variable. </dd></dl>

</div>
</div>
<a id="aae0f95ddf7f8793c2333e1ff0acdb74d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae0f95ddf7f8793c2333e1ff0acdb74d">&sect;&nbsp;</a></span>LET_check()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LET_check </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vérifie que input possède bien la structure minimale de let. </p>
<p>Vérifie que let ait le bon format : Format minimal : (let () atome) qui renvoie atome. Ne vérifie pas que les arguments ont le bon format c'est LET_eval qui s'en charge. Si erreur affiche un WARNING_MSG et renvoie 0.</p>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie 1 si format correct, 0 sinon. </dd></dl>

</div>
</div>
<a id="ae625530b96120d1101e6332938c8d580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae625530b96120d1101e6332938c8d580">&sect;&nbsp;</a></span>LET_eval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structobject__t.html">object</a> LET_eval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evalue le corps d'un let dans l'environnement env. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>: input total d'un let (let ...) </td></tr>
    <tr><td class="paramname">env</td><td>: Environnement dans lequel seront faite les évaluations.</td></tr>
  </table>
  </dd>
</dl>
<p>Evalue les arguments à l'aide de sfs_eval, en construisant une instruction (define args value). La gestion des erreurs est donc faite par sfs_eval et EVAL_define. Evalue le body avec sfs_eval dans l'env en ayant construit une instruction avec begin : (begin body ..) <br />
 ATTENTION <br />
Ne fait pas de test de la forme de input.</p>
<dl class="section see"><dt>Voir également</dt><dd><a class="el" href="eval_8c.html#a019ed7c50b864c42ea880ac81aec0048" title="Evalue un define. ">EVAL_define</a> </dd>
<dd>
<a class="el" href="eval_8c.html#ae380eb697aba625d9557508c5ce78230" title="Fonction d&#39;évaluation d&#39;expression scheme. ">sfs_eval</a></dd></dl>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie l'évaluation de d'un let dans env. </dd></dl>

</div>
</div>
<a id="ae380eb697aba625d9557508c5ce78230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae380eb697aba625d9557508c5ce78230">&sect;&nbsp;</a></span>sfs_eval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structobject__t.html">object</a> sfs_eval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fonction d'évaluation d'expression scheme. </p>
<p>Evaluation de l'input. Renvoie NULL si : input est NULL</p><ul>
<li>Si on a un symbole correspondant à un forme scheme seul.</li>
<li>Si on donne une variable inexistante.</li>
<li>Si on commence une liste avec un symbole qui n'est ni un mot ni une variable.</li>
<li>Si par inadvertance le car de input est NULL.</li>
</ul>
<dl class="section see"><dt>Voir également</dt><dd>is_form(object symbol, int* forme);</dd></dl>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie l'objet évalué. </dd></dl>

</div>
</div>
<a id="ae6a1f129c513c24456d85a102835bd32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6a1f129c513c24456d85a102835bd32">&sect;&nbsp;</a></span>sfs_eval_compound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structobject__t.html">object</a> sfs_eval_compound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>pair</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evalue un agrégat.  : L'entrée de l'utilisateur dont le symbole est évalué.  : L'environnement dans lequel on est. </p>
<p>pair correspond à l'entrée de l'utilisateur à la seule différence que le premier élément de l'instruction n'est pas un symbole mais un agregat : Le symbole a été interprété. Procède par étape : Construit un environnement dont le père est env. Créer dans cet environnement les variables associées à l'agregat (paramètres). Exécute le body par sfs_eval dans cet environnement. Ne supprime pas l'environnement.</p>
<p>Renvoie l'évaluation du body.</p>
<p>Si trop d'arguments sont données affiche un warning, et retourne NULL. Si il manque des arguments, renvoie NULL et affiche un warning. </p><dl class="section return"><dt>Renvoie</dt><dd>Renvoie l'évaluation du body sur les arguments. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Généré par &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.12
</small></address>
</body>
</html>
