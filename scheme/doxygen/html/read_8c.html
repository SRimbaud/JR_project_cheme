<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Livrable3 Informatique Phelma SICOM: Référence du fichier src/read.c</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Livrable3 Informatique Phelma SICOM
   </div>
   <div id="projectbrief">Interpréteur Scheme</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Généré par Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Recherche');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Page&#160;principale</span></a></li>
      <li><a href="pages.html"><span>Pages&#160;associées</span></a></li>
      <li><a href="annotated.html"><span>Structures&#160;de&#160;données</span></a></li>
      <li class="current"><a href="files.html"><span>Fichiers</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Recherche" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>Liste&#160;des&#160;fichiers</span></a></li>
      <li><a href="globals.html"><span>Variables&#160;globale</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#enum-members">Énumérations</a> &#124;
<a href="#func-members">Fonctions</a>  </div>
  <div class="headertitle">
<div class="title">Référence du fichier read.c</div>  </div>
</div><!--header-->
<div class="contents">

<p>Read routine for SFS.  
<a href="#details">Plus de détails...</a></p>
<div class="textblock"><code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;ctype.h&gt;</code><br />
<code>#include &quot;<a class="el" href="read_8h_source.html">read.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Graphe des dépendances par inclusion de read.c:</div>
<div class="dyncontent">
<div class="center"><img src="read_8c__incl.png" border="0" usemap="#src_2read_8c" alt=""/></div>
<!-- MAP 0 -->
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Énumérations</h2></td></tr>
<tr class="memitem:a794da11e5e95baea1892357a25b44336"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="read_8c.html#a794da11e5e95baea1892357a25b44336">EXPRESSION_TYPE_T</a> { <br />
&#160;&#160;<a class="el" href="read_8c.html#a794da11e5e95baea1892357a25b44336acfe24a7b308a82835c8a9a9a89bc4ca2">NOTHING</a>, 
<a class="el" href="read_8c.html#a794da11e5e95baea1892357a25b44336a3789e89d60fe0d18548ebc6d3080e20f">STRING_ATOME</a>, 
<a class="el" href="read_8c.html#a794da11e5e95baea1892357a25b44336a26a9892b61e0aa5a24c1c1c7d57ebaab">BASIC_ATOME</a>, 
<a class="el" href="read_8c.html#a794da11e5e95baea1892357a25b44336a52eaf1b8684255efd41eadf2e613cf28">S_EXPR_PARENTHESIS</a>, 
<br />
&#160;&#160;<a class="el" href="read_8c.html#a794da11e5e95baea1892357a25b44336adbd1812bee789fbf3548cf79d3f2b400">FINISHED</a>
<br />
 }</td></tr>
<tr class="separator:a794da11e5e95baea1892357a25b44336"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Fonctions</h2></td></tr>
<tr class="memitem:a2944755a32d2f89b5585df862eaa4980"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="read_8c.html#a2944755a32d2f89b5585df862eaa4980">flip</a> (uint *i)</td></tr>
<tr class="memdesc:a2944755a32d2f89b5585df862eaa4980"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prend la négation de i. Equivalent à une porte non.  <a href="#a2944755a32d2f89b5585df862eaa4980">Plus de détails...</a><br /></td></tr>
<tr class="separator:a2944755a32d2f89b5585df862eaa4980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f436bcd6cba7ebae92b4278d43cf7d9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f436bcd6cba7ebae92b4278d43cf7d9"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="read_8c.html#a5f436bcd6cba7ebae92b4278d43cf7d9">first_usefull_char</a> (char *line)</td></tr>
<tr class="memdesc:a5f436bcd6cba7ebae92b4278d43cf7d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">retourne un pointeur sur le premier caractere utile dans line ou NULL si line ne contient que des espaces et des commentaires <br /></td></tr>
<tr class="separator:a5f436bcd6cba7ebae92b4278d43cf7d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46cec1fd91fe64ce3df1940755ea173e"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="read_8c.html#a46cec1fd91fe64ce3df1940755ea173e">sfs_get_sexpr</a> (char *input, FILE *fp)</td></tr>
<tr class="memdesc:a46cec1fd91fe64ce3df1940755ea173e"><td class="mdescLeft">&#160;</td><td class="mdescRight">extrait la prochaine S-Expression dans le flux fp et la stocke dans input (meme si elle est repartie sur plusieurs lignes)  <a href="#a46cec1fd91fe64ce3df1940755ea173e">Plus de détails...</a><br /></td></tr>
<tr class="separator:a46cec1fd91fe64ce3df1940755ea173e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb9a4ca33faccde4ffe139eff1909e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structobject__t.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="read_8c.html#a5eb9a4ca33faccde4ffe139eff1909e4">sfs_read</a> (char *input, uint *here)</td></tr>
<tr class="memdesc:a5eb9a4ca33faccde4ffe139eff1909e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lit une expression entrée par l'utilisateur et construit l'objet correspondant.  <a href="#a5eb9a4ca33faccde4ffe139eff1909e4">Plus de détails...</a><br /></td></tr>
<tr class="separator:a5eb9a4ca33faccde4ffe139eff1909e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c3a38292d0be403baa7cc3cc2747849"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structobject__t.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="read_8c.html#a6c3a38292d0be403baa7cc3cc2747849">sfs_read_atom</a> (char *input, uint *here)</td></tr>
<tr class="memdesc:a6c3a38292d0be403baa7cc3cc2747849"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lit une entrée utilisateur et construit l'objet correspondant.  <a href="#a6c3a38292d0be403baa7cc3cc2747849">Plus de détails...</a><br /></td></tr>
<tr class="separator:a6c3a38292d0be403baa7cc3cc2747849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8829af52b575d435c2919af838e459bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structobject__t.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="read_8c.html#a8829af52b575d435c2919af838e459bc">sfs_read_pair</a> (char *stream, uint *i)</td></tr>
<tr class="memdesc:a8829af52b575d435c2919af838e459bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construit une liste à partir d'une entrée utilisateur. Récursif.  <a href="#a8829af52b575d435c2919af838e459bc">Plus de détails...</a><br /></td></tr>
<tr class="separator:a8829af52b575d435c2919af838e459bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab21f6839688301ccb9e157c5f16c58b3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="read_8c.html#ab21f6839688301ccb9e157c5f16c58b3">sfs_type_atom</a> (char *chaine, uint *here)</td></tr>
<tr class="memdesc:ab21f6839688301ccb9e157c5f16c58b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">détermine le type d'un atome et le renvoie. N'incrémente pas here.  <a href="#ab21f6839688301ccb9e157c5f16c58b3">Plus de détails...</a><br /></td></tr>
<tr class="separator:ab21f6839688301ccb9e157c5f16c58b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cc1a614faace621e97aa57ac764ec93"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="read_8c.html#a9cc1a614faace621e97aa57ac764ec93">OBJECT_int_update</a> (<a class="el" href="structobject__t.html">object</a> o, char *input, uint *here)</td></tr>
<tr class="memdesc:a9cc1a614faace621e97aa57ac764ec93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extrait un entier de l'entrée utilisateur et créé l'objet correspondant.  <a href="#a9cc1a614faace621e97aa57ac764ec93">Plus de détails...</a><br /></td></tr>
<tr class="separator:a9cc1a614faace621e97aa57ac764ec93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe5cdc861f097aa41cb4e8ad88d53a8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="read_8c.html#abbe5cdc861f097aa41cb4e8ad88d53a8">OBJECT_real_update</a> (<a class="el" href="structobject__t.html">object</a> o, char *input, uint *here)</td></tr>
<tr class="memdesc:abbe5cdc861f097aa41cb4e8ad88d53a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lit un réel sur une entrée utilisateur.  <a href="#abbe5cdc861f097aa41cb4e8ad88d53a8">Plus de détails...</a><br /></td></tr>
<tr class="separator:abbe5cdc861f097aa41cb4e8ad88d53a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedd5c9ba9c7b85317ca31157893a9378"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="read_8c.html#aedd5c9ba9c7b85317ca31157893a9378">OBJECT_character_update</a> (<a class="el" href="structobject__t.html">object</a> o, char *input, uint *here)</td></tr>
<tr class="memdesc:aedd5c9ba9c7b85317ca31157893a9378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extrait le caractère de input et l'enregistre dans object. Place here sur caractère suivant.  <a href="#aedd5c9ba9c7b85317ca31157893a9378">Plus de détails...</a><br /></td></tr>
<tr class="separator:aedd5c9ba9c7b85317ca31157893a9378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9ebedee6be777ef6b05c9b3a651aeee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="read_8c.html#ac9ebedee6be777ef6b05c9b3a651aeee">OBJECT_string_update</a> (<a class="el" href="structobject__t.html">object</a> o, char *input, uint *here)</td></tr>
<tr class="memdesc:ac9ebedee6be777ef6b05c9b3a651aeee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extrait la chaine de input et l'enregistre dans object.  <a href="#ac9ebedee6be777ef6b05c9b3a651aeee">Plus de détails...</a><br /></td></tr>
<tr class="separator:ac9ebedee6be777ef6b05c9b3a651aeee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa7a3fe5326b17d2e2858848680c1b44"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="read_8c.html#aaa7a3fe5326b17d2e2858848680c1b44">OBJECT_boolean_update</a> (<a class="el" href="structobject__t.html">object</a> *o, char *input, uint *here)</td></tr>
<tr class="memdesc:aaa7a3fe5326b17d2e2858848680c1b44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extrait le booléen de l'input. Déplace here au caractère suivant.  <a href="#aaa7a3fe5326b17d2e2858848680c1b44">Plus de détails...</a><br /></td></tr>
<tr class="separator:aaa7a3fe5326b17d2e2858848680c1b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c4c9ac5d3fa743f8b60a812c7620f7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="read_8c.html#a46c4c9ac5d3fa743f8b60a812c7620f7">OBJECT_symbol_update</a> (<a class="el" href="structobject__t.html">object</a> o, char *input, uint *here)</td></tr>
<tr class="memdesc:a46c4c9ac5d3fa743f8b60a812c7620f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extrait un symbole de la chaine input et met à jour l'object.  <a href="#a46c4c9ac5d3fa743f8b60a812c7620f7">Plus de détails...</a><br /></td></tr>
<tr class="separator:a46c4c9ac5d3fa743f8b60a812c7620f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Description détaillée</h2>
<div class="textblock"><p>Read routine for SFS. </p>
<dl class="section author"><dt>Auteur</dt><dd>François Cayre &lt;cayre.(null)&gt; </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Fri Jun 15 18:31:05 2012 Read routine for SFS. </dd></dl>
</div><h2 class="groupheader">Documentation du type de l'énumération</h2>
<a class="anchor" id="a794da11e5e95baea1892357a25b44336"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="read_8c.html#a794da11e5e95baea1892357a25b44336">EXPRESSION_TYPE_T</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Valeurs énumérées</th></tr><tr><td class="fieldname"><a class="anchor" id="a794da11e5e95baea1892357a25b44336acfe24a7b308a82835c8a9a9a89bc4ca2"></a>NOTHING&#160;</td><td class="fielddoc">
<p>rien n'a ete trouve encore.. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a794da11e5e95baea1892357a25b44336a3789e89d60fe0d18548ebc6d3080e20f"></a>STRING_ATOME&#160;</td><td class="fielddoc">
<p>la premiere trouvee dans la ligne semble etre un atome </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a794da11e5e95baea1892357a25b44336a26a9892b61e0aa5a24c1c1c7d57ebaab"></a>BASIC_ATOME&#160;</td><td class="fielddoc">
<p>la premiere trouvee dans la ligne semble etre d'une chaine </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a794da11e5e95baea1892357a25b44336a52eaf1b8684255efd41eadf2e613cf28"></a>S_EXPR_PARENTHESIS&#160;</td><td class="fielddoc">
<p>la premiere trouvee dans la ligne semble etre une expression parenthesee </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a794da11e5e95baea1892357a25b44336adbd1812bee789fbf3548cf79d3f2b400"></a>FINISHED&#160;</td><td class="fielddoc">
<p>on a trouve une S-Expr bien formee </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Documentation des fonctions</h2>
<a class="anchor" id="a2944755a32d2f89b5585df862eaa4980"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flip </td>
          <td>(</td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prend la négation de i. Equivalent à une porte non. </p>
<dl class="section return"><dt>Renvoie</dt><dd>Retourne !i. </dd></dl>

</div>
</div>
<a class="anchor" id="aaa7a3fe5326b17d2e2858848680c1b44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OBJECT_boolean_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a> *&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>here</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extrait le booléen de l'input. Déplace here au caractère suivant. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>: l'objet dans lequel on enregistre. </td></tr>
    <tr><td class="paramname">input</td><td>: la chaine contenant le booléen. </td></tr>
    <tr><td class="paramname">here</td><td>: Le curseur sur le premier caractère utile de input.</td></tr>
  </table>
  </dd>
</dl>
<p>La fonction vérifie que le booléen entré en est bien un (#t ou #f) autrement elle le considère comme mal entré. Dans ce cas elle appelle WARNING_MSG et retourne 1. Elle place ensuite o à vrai ou à faux qui sont des variables globales de <a class="el" href="repl_8c.html" title="Boucle principale interpréteur scheme. ">repl.c</a> (pas implémenté de cette façon encore).</p>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie 0 si tout de passe bien, 1 sinon. </dd></dl>

</div>
</div>
<a class="anchor" id="aedd5c9ba9c7b85317ca31157893a9378"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OBJECT_character_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>here</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extrait le caractère de input et l'enregistre dans object. Place here sur caractère suivant. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>: l'objet dans lequel on enregistre. </td></tr>
    <tr><td class="paramname">input</td><td>: la chaine contenant le caractère. </td></tr>
    <tr><td class="paramname">here</td><td>: Le curseur sur la chaine contenant le caractère</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie 0 si tout de passe bien 1 sinon. </dd></dl>

</div>
</div>
<a class="anchor" id="a9cc1a614faace621e97aa57ac764ec93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OBJECT_int_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>here</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extrait un entier de l'entrée utilisateur et créé l'objet correspondant. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>: L'object dans lequel mettre l'entier. </td></tr>
    <tr><td class="paramname">input</td><td>: Entrée de l'utilisateur. </td></tr>
    <tr><td class="paramname">here</td><td>: Curseur sur la chaine de l'utilisateur.</td></tr>
  </table>
  </dd>
</dl>
<p>On a contrôle de l'erreur ici. Si l'entier contient des caractères qui ne sont pas des parenthèses ouvrantes ou fermantes de listes celui-ci est considéré comme mauvais. Le type de l'object est alors mis à SFS_UNKNOWN et la fonction s'arrête en retournant 1. L'entier est alors tronqué.<br />
La fonction gère aussi l'overflow, si l'entier est trop grand (ou trop petit négatif) le type est mis à SFS_NUMBER et la valeur à + ou -inf.(voir NUM_build ) Dans ce cas affiche un WARNING et retourne 2.<br />
 Voir <a href="http://manpagesfr.free.fr/man/man3/strtol.3.html ">strtol </a> pour plus d'informations.</p>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie 0, 1 si l'entier entré n'en est pas un, 2 si overflow. </dd></dl>

</div>
</div>
<a class="anchor" id="abbe5cdc861f097aa41cb4e8ad88d53a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OBJECT_real_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>here</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lit un réel sur une entrée utilisateur. </p>
<p>Lit un réel. La virgule doit être un point. Cette fonction est appelée par OBJECT_int_update lorsque le caractère d'arrêt est un point son retour est utilisé par cette même fonction.</p>
<dl class="section see"><dt>Voir également</dt><dd>strtold</dd></dl>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie 2 si overflow, 1 si entrée mauvaise, 0 sinon. </dd></dl>

</div>
</div>
<a class="anchor" id="ac9ebedee6be777ef6b05c9b3a651aeee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OBJECT_string_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>here</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extrait la chaine de input et l'enregistre dans object. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>: l'objet dans lequel on enregistre. </td></tr>
    <tr><td class="paramname">input</td><td>: la chaine contenant la chaine. </td></tr>
    <tr><td class="paramname">here</td><td>: Le curseur sur le premier caractère utile de input.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie 0 si tout de passe bien 1 sinon. </dd></dl>

</div>
</div>
<a class="anchor" id="a46c4c9ac5d3fa743f8b60a812c7620f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OBJECT_symbol_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>here</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extrait un symbole de la chaine input et met à jour l'object. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>: l'object de type symbole à éditer </td></tr>
    <tr><td class="paramname">input</td><td>: La chaine entrée par l'utilisateur. </td></tr>
    <tr><td class="paramname">here</td><td>le curseur sur la chaine.</td></tr>
  </table>
  </dd>
</dl>
<p>Cette fonction vérifie que chaque caractère du symbole est bien un supporté par scheme selon la R5RS voir isealum pour plus de détails. Dans le cas d'une erreur passe le type à SFS_UNKNOWN . Dans ce cas elle renvoie 1. </p><dl class="section return"><dt>Renvoie</dt><dd>: Renvoie O si Aucun problème n'est détecté, 1 sinon. </dd></dl>

</div>
</div>
<a class="anchor" id="a46cec1fd91fe64ce3df1940755ea173e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint sfs_get_sexpr </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>extrait la prochaine S-Expression dans le flux fp et la stocke dans input (meme si elle est repartie sur plusieurs lignes) </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>(FILE *) flux d'entree (ouvert en ecriture, mode texte) </td></tr>
    <tr><td class="paramname">input</td><td>(char *) chaine allouee de taille BIGSTRING, dans laquelle la S-Expression sera stockée</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>S_OK si une S-Expression apparemment valide a ete trouvee </dd>
<dd>
S_KO si on n'a pas trouve de S-Expression valide </dd>
<dd>
S_END si fin de fichier atteinte sans avoir lu de caractere utile.</dd></dl>
<p>sfs_get_sexpr commence par lire une ligne dans fp, puis compte le nombre de parentheses ouvrantes et fermantes sur la ligne. Les parentheses dans des chaines et les caracteres Scheme #( et #) ne sont pas comptes.</p>
<p>Si le compte devient zéro et que</p><ul>
<li>la ligne est fini, la fonction retourne S_OK<ul>
<li>la ligne n'est pas fini la fonction retourne S_KO</li>
</ul>
</li>
</ul>
<p>S'il y a plus de parentheses fermantes qu'ouvrantes, la fonction retourne S_KO. Les commentaires et espaces qui figurent a la fin de chaque ligne sont remplacés par un espace. Les espaces qui figurent a la fin de la S-Expression (y compris '<br />
') sont supprimés.</p>
<p>Attention : cette fonction refuse les S-Expression multiple sur une seule ligne. Ainsi : a b c (qqchose) (autrechose) (qqchose) 78 seront considereees comme des erreurs et la fonction retournera S_KO</p>
<dl class="section pre"><dt>Précondition</dt><dd>fp doit etre prealablement ouvert en lecture </dd>
<dd>
input doit etre prealablement alloue en memoire, de taille BIGSTRING </dd></dl>

</div>
</div>
<a class="anchor" id="a5eb9a4ca33faccde4ffe139eff1909e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structobject__t.html">object</a> sfs_read </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>here</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lit une expression entrée par l'utilisateur et construit l'objet correspondant. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>: Entrée utilisateur </td></tr>
    <tr><td class="paramname">here</td><td>: Curseur sur le lieu ou l'on se situe dans input.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie l'object correspondant à l'input </dd></dl>

</div>
</div>
<a class="anchor" id="a6c3a38292d0be403baa7cc3cc2747849"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structobject__t.html">object</a> sfs_read_atom </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>here</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lit une entrée utilisateur et construit l'objet correspondant. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>: Entrée </td></tr>
    <tr><td class="paramname">here</td><td>: curseur sur l'entrée.</td></tr>
  </table>
  </dd>
</dl>
<p>L'objet renvoyé possède le type SFS_UNKNOWN si l'entrée utilisateur est mauvaise. Dans ce cas la fonction affiche un warning spécifiant que le type n'est pas reconnu. Elle renvoie alors NULL. Fait appel à sfs_type_atom pour identifier le type de l'entrée. Lorsque le type n'est pas reconnu elle renvoie également un warning sans interrompre le programme. Pour plus de détails sur les erreurs voir :</p><ul>
<li><a class="el" href="read_8c.html#a9cc1a614faace621e97aa57ac764ec93" title="Extrait un entier de l&#39;entrée utilisateur et créé l&#39;objet correspondant. ">OBJECT_int_update(object o, char* input, uint* here)</a></li>
<li><a class="el" href="read_8c.html#aedd5c9ba9c7b85317ca31157893a9378" title="Extrait le caractère de input et l&#39;enregistre dans object. Place here sur caractère suivant...">OBJECT_character_update(object o, char* input, uint* here)</a></li>
<li><a class="el" href="read_8c.html#ac9ebedee6be777ef6b05c9b3a651aeee" title="Extrait la chaine de input et l&#39;enregistre dans object. ">OBJECT_string_update(object o, char* input, uint* here)</a></li>
<li>OBJECT_boolean_update(object o, char* input, uint* here)</li>
<li><a class="el" href="read_8c.html#a46c4c9ac5d3fa743f8b60a812c7620f7" title="Extrait un symbole de la chaine input et met à jour l&#39;object. ">OBJECT_symbol_update(object o, char* input, uint*here)</a></li>
</ul>
<p>Types reconnus :</p><ul>
<li>entier signés</li>
<li>caractères</li>
<li>booléens</li>
<li>symboles</li>
<li>listes (paires)</li>
<li>nil</li>
<li>chaine de caractère</li>
</ul>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie l'envoie construit. </dd></dl>

</div>
</div>
<a class="anchor" id="a8829af52b575d435c2919af838e459bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structobject__t.html">object</a> sfs_read_pair </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construit une liste à partir d'une entrée utilisateur. Récursif. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>: Entrée. </td></tr>
    <tr><td class="paramname">i</td><td>: Curseur sur l'entrée. Incrémente le curseur.</td></tr>
  </table>
  </dd>
</dl>
<p>Fonction récursive. Les conditions sont une parenthèse fermante ou une fin de chaine. Dans ce cas cette fonction retourne la variable globale nil.</p>
<dl class="section see"><dt>Voir également</dt><dd><a class="el" href="repl_8c.html" title="Boucle principale interpréteur scheme. ">repl.c</a></dd></dl>
<dl class="section return"><dt>Renvoie</dt><dd>: Renvoie un object qui correspond à la liste construite. </dd></dl>

</div>
</div>
<a class="anchor" id="ab21f6839688301ccb9e157c5f16c58b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sfs_type_atom </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>chaine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>here</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>détermine le type d'un atome et le renvoie. N'incrémente pas here. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">chaine</td><td>: Chaine dans laquelle trouver le type de l'atome  here : curseur sur la chaine.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>: Renvoie le type de l'atome. Retourne SFS_UNKNOWN aucun type ne correspond. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Généré par &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
