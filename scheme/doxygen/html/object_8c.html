<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Livrable1 Informatique Phelma SICOM: Référence du fichier src/object.c</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Livrable1 Informatique Phelma SICOM
   </div>
   <div id="projectbrief">Interpréteur Scheme</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Généré par Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Recherche');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Recherche');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Fonctions</a>  </div>
  <div class="headertitle">
<div class="title">Référence du fichier object.c</div>  </div>
</div><!--header-->
<div class="contents">

<p>Fonctions relatives à la structure object.  
<a href="#details">Plus de détails...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="object_8h_source.html">object.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Graphe des dépendances par inclusion de object.c:</div>
<div class="dyncontent">
<div class="center"><img src="object_8c__incl.png" border="0" usemap="#src_2object_8c" alt=""/></div>
<!-- MAP 0 -->
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Fonctions</h2></td></tr>
<tr class="memitem:ae588b0336388f82cf984bca34a66fe99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structobject__t.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#ae588b0336388f82cf984bca34a66fe99">make_object</a> (uint type)</td></tr>
<tr class="memdesc:ae588b0336388f82cf984bca34a66fe99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alloue un objet de type type, vérifie l'alloc.  <a href="#ae588b0336388f82cf984bca34a66fe99">Plus de détails...</a><br /></td></tr>
<tr class="separator:ae588b0336388f82cf984bca34a66fe99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0175150d600f632a2675d80b72823f45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structobject__t.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#a0175150d600f632a2675d80b72823f45">make_nil</a> (void)</td></tr>
<tr class="memdesc:a0175150d600f632a2675d80b72823f45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alloue l'objet nil qui marque fin de o. Programme se termine si l'alloc rate.  <a href="#a0175150d600f632a2675d80b72823f45">Plus de détails...</a><br /></td></tr>
<tr class="separator:a0175150d600f632a2675d80b72823f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa54a323be37760f91b9a423760d800d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structobject__t.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#aa54a323be37760f91b9a423760d800d3">make_true</a> (void)</td></tr>
<tr class="memdesc:aa54a323be37760f91b9a423760d800d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Créé le booléen vrai (variable globale). Fonction appelée dans <a class="el" href="repl_8c.html#ac7892fa748bffcd6854f8b7adeb40ba0" title="Initialise les variables globales de l&#39;interpréteur. ">init_interpreter()</a>.  <a href="#aa54a323be37760f91b9a423760d800d3">Plus de détails...</a><br /></td></tr>
<tr class="separator:aa54a323be37760f91b9a423760d800d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c208c0fbec6ecf85e3de7949b7691cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structobject__t.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#a0c208c0fbec6ecf85e3de7949b7691cf">make_false</a> (void)</td></tr>
<tr class="memdesc:a0c208c0fbec6ecf85e3de7949b7691cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Créé le booléen faux (variable globale). Fonction appelée dans <a class="el" href="repl_8c.html#ac7892fa748bffcd6854f8b7adeb40ba0" title="Initialise les variables globales de l&#39;interpréteur. ">init_interpreter()</a>.  <a href="#a0c208c0fbec6ecf85e3de7949b7691cf">Plus de détails...</a><br /></td></tr>
<tr class="separator:a0c208c0fbec6ecf85e3de7949b7691cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabab05a704acf24c0040b7223908c858"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#aabab05a704acf24c0040b7223908c858">make_forms</a> ()</td></tr>
<tr class="memdesc:aabab05a704acf24c0040b7223908c858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise formes de l'interpréteur.  <a href="#aabab05a704acf24c0040b7223908c858">Plus de détails...</a><br /></td></tr>
<tr class="separator:aabab05a704acf24c0040b7223908c858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421310d9e2d05d70789086bd9418656c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#a421310d9e2d05d70789086bd9418656c">OBJECT_set_cxr</a> (<a class="el" href="structobject__t.html">object</a> o, <a class="el" href="structobject__t.html">object</a> val, char *place)</td></tr>
<tr class="memdesc:a421310d9e2d05d70789086bd9418656c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifie l'emplacement donné et y met la variable val.  <a href="#a421310d9e2d05d70789086bd9418656c">Plus de détails...</a><br /></td></tr>
<tr class="separator:a421310d9e2d05d70789086bd9418656c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d4c460873067cf00d877f60cdd285ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#a4d4c460873067cf00d877f60cdd285ec">OBJECT_set_cdr</a> (<a class="el" href="structobject__t.html">object</a> o, <a class="el" href="structobject__t.html">object</a> cdr)</td></tr>
<tr class="memdesc:a4d4c460873067cf00d877f60cdd285ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Met à jour le cdr de o avec l'object cdr.  <a href="#a4d4c460873067cf00d877f60cdd285ec">Plus de détails...</a><br /></td></tr>
<tr class="separator:a4d4c460873067cf00d877f60cdd285ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ccb3f30397a60a9d663f43c4dc28514"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#a8ccb3f30397a60a9d663f43c4dc28514">OBJECT_set_car</a> (<a class="el" href="structobject__t.html">object</a> o, <a class="el" href="structobject__t.html">object</a> car)</td></tr>
<tr class="memdesc:a8ccb3f30397a60a9d663f43c4dc28514"><td class="mdescLeft">&#160;</td><td class="mdescRight">Met à jour le car de o avec l'objet car.  <a href="#a8ccb3f30397a60a9d663f43c4dc28514">Plus de détails...</a><br /></td></tr>
<tr class="separator:a8ccb3f30397a60a9d663f43c4dc28514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade583a8335577c269af8b9cc37567699"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structobject__t.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#ade583a8335577c269af8b9cc37567699">OBJECT_build_pair</a> (<a class="el" href="structobject__t.html">object</a> car, <a class="el" href="structobject__t.html">object</a> cdr)</td></tr>
<tr class="memdesc:ade583a8335577c269af8b9cc37567699"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construit une paire avec un car et cdr donné.  <a href="#ade583a8335577c269af8b9cc37567699">Plus de détails...</a><br /></td></tr>
<tr class="separator:ade583a8335577c269af8b9cc37567699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba2f19194908157a74d7250b28929484"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structobject__t.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#aba2f19194908157a74d7250b28929484">OBJECT_build_symbol</a> (char *symbol)</td></tr>
<tr class="memdesc:aba2f19194908157a74d7250b28929484"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construit un object de type symbole contenant symbole.  <a href="#aba2f19194908157a74d7250b28929484">Plus de détails...</a><br /></td></tr>
<tr class="separator:aba2f19194908157a74d7250b28929484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09933fca31b4b68d1e8d1d8f26f7ce45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structobject__t.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#a09933fca31b4b68d1e8d1d8f26f7ce45">OBJECT_build_cpy</a> (<a class="el" href="structobject__t.html">object</a> o)</td></tr>
<tr class="memdesc:a09933fca31b4b68d1e8d1d8f26f7ce45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copie l'objet o en en allouant un nouveau.  <a href="#a09933fca31b4b68d1e8d1d8f26f7ce45">Plus de détails...</a><br /></td></tr>
<tr class="separator:a09933fca31b4b68d1e8d1d8f26f7ce45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f88c49537b92e95b7d33660446ee8c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#a5f88c49537b92e95b7d33660446ee8c7">OBJECT_destroy</a> (<a class="el" href="structobject__t.html">object</a> *o)</td></tr>
<tr class="memdesc:a5f88c49537b92e95b7d33660446ee8c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supprime un objet.  <a href="#a5f88c49537b92e95b7d33660446ee8c7">Plus de détails...</a><br /></td></tr>
<tr class="separator:a5f88c49537b92e95b7d33660446ee8c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1356f35f47fdbb828bc06a5884d74ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#ad1356f35f47fdbb828bc06a5884d74ed">OBJECT_destroy_pair</a> (<a class="el" href="structobject__t.html">object</a> *o)</td></tr>
<tr class="memdesc:ad1356f35f47fdbb828bc06a5884d74ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supprime une paire. Fonction récursive.  <a href="#ad1356f35f47fdbb828bc06a5884d74ed">Plus de détails...</a><br /></td></tr>
<tr class="separator:ad1356f35f47fdbb828bc06a5884d74ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d783570ac14dc2efa3f0565e162a6e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structobject__t.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#a1d783570ac14dc2efa3f0565e162a6e8">OBJECT_built_short_quote</a> (char *input, uint *here)</td></tr>
<tr class="memdesc:a1d783570ac14dc2efa3f0565e162a6e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construit le début de pair pour quote sous forme '.  <a href="#a1d783570ac14dc2efa3f0565e162a6e8">Plus de détails...</a><br /></td></tr>
<tr class="separator:a1d783570ac14dc2efa3f0565e162a6e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d7084a07b321423f9cd922529fd8ed8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#a0d7084a07b321423f9cd922529fd8ed8">OBJECT_isempty</a> (<a class="el" href="structobject__t.html">object</a> o)</td></tr>
<tr class="memdesc:a0d7084a07b321423f9cd922529fd8ed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vérifie si un objet est vide (égal à NULL)  <a href="#a0d7084a07b321423f9cd922529fd8ed8">Plus de détails...</a><br /></td></tr>
<tr class="separator:a0d7084a07b321423f9cd922529fd8ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486b361de0c6c18f7227158b12dbfd4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structobject__t.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#a486b361de0c6c18f7227158b12dbfd4a">OBJECT_get_cxr</a> (<a class="el" href="structobject__t.html">object</a> o, char *place)</td></tr>
<tr class="memdesc:a486b361de0c6c18f7227158b12dbfd4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renvoie de l'élement de la pair correspondant à la chaine.  <a href="#a486b361de0c6c18f7227158b12dbfd4a">Plus de détails...</a><br /></td></tr>
<tr class="separator:a486b361de0c6c18f7227158b12dbfd4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64f2fee85ada6041d0c74a250c419686"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#a64f2fee85ada6041d0c74a250c419686">OBJECT_rewrite</a> (<a class="el" href="structobject__t.html">object</a> changed, <a class="el" href="structobject__t.html">object</a> nouveau)</td></tr>
<tr class="memdesc:a64f2fee85ada6041d0c74a250c419686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Réécris avec la valeur de nouveau.  <a href="#a64f2fee85ada6041d0c74a250c419686">Plus de détails...</a><br /></td></tr>
<tr class="separator:a64f2fee85ada6041d0c74a250c419686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab49b1649bad38a97c44b7713731cea48"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#ab49b1649bad38a97c44b7713731cea48">OBJECT_isEqual</a> (<a class="el" href="structobject__t.html">object</a> a, <a class="el" href="structobject__t.html">object</a> b)</td></tr>
<tr class="memdesc:ab49b1649bad38a97c44b7713731cea48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare deux object Renvoie 1 s'ils sont égaux 0 sinon.  <a href="#ab49b1649bad38a97c44b7713731cea48">Plus de détails...</a><br /></td></tr>
<tr class="separator:ab49b1649bad38a97c44b7713731cea48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8467e456f150c3514808c26c6864497d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#a8467e456f150c3514808c26c6864497d">OBJECT_cmp_bool</a> (<a class="el" href="structobject__t.html">object</a> a, <a class="el" href="structobject__t.html">object</a> b)</td></tr>
<tr class="memdesc:a8467e456f150c3514808c26c6864497d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare 2 booléens. Renvoie 0 s'ils ne sont pas booléens.  <a href="#a8467e456f150c3514808c26c6864497d">Plus de détails...</a><br /></td></tr>
<tr class="separator:a8467e456f150c3514808c26c6864497d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a7c4f6341e5477c8cf12d9fa4b8048"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#aa8a7c4f6341e5477c8cf12d9fa4b8048">OBJECT_cmp_number</a> (<a class="el" href="structobject__t.html">object</a> a, <a class="el" href="structobject__t.html">object</a> b)</td></tr>
<tr class="memdesc:aa8a7c4f6341e5477c8cf12d9fa4b8048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare deux objets de type SFS_NUMBER.  <a href="#aa8a7c4f6341e5477c8cf12d9fa4b8048">Plus de détails...</a><br /></td></tr>
<tr class="separator:aa8a7c4f6341e5477c8cf12d9fa4b8048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b5035114247cba825eafb2ef1d34c0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#a85b5035114247cba825eafb2ef1d34c0">OBJECT_cmp_symb</a> (<a class="el" href="structobject__t.html">object</a> a, char *symbol)</td></tr>
<tr class="memdesc:a85b5035114247cba825eafb2ef1d34c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a avec le symbol symbol.  <a href="#a85b5035114247cba825eafb2ef1d34c0">Plus de détails...</a><br /></td></tr>
<tr class="separator:a85b5035114247cba825eafb2ef1d34c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b6a20ced958c8d2f5fda6c0e8f191b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#ab4b6a20ced958c8d2f5fda6c0e8f191b">OBJECT_cmp_is_inf</a> (const <a class="el" href="structobject__t.html">object</a> a, const <a class="el" href="structobject__t.html">object</a> b, int *flag)</td></tr>
<tr class="memdesc:ab4b6a20ced958c8d2f5fda6c0e8f191b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renvoie a &lt; b.  <a href="#ab4b6a20ced958c8d2f5fda6c0e8f191b">Plus de détails...</a><br /></td></tr>
<tr class="separator:ab4b6a20ced958c8d2f5fda6c0e8f191b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab418f8b63a1b1ed89a04ea1cd566a31e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#ab418f8b63a1b1ed89a04ea1cd566a31e">OBJECT_cmp_is_sup</a> (const <a class="el" href="structobject__t.html">object</a> a, const <a class="el" href="structobject__t.html">object</a> b, int *flag)</td></tr>
<tr class="memdesc:ab418f8b63a1b1ed89a04ea1cd566a31e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renvoie a &gt; b.  <a href="#ab418f8b63a1b1ed89a04ea1cd566a31e">Plus de détails...</a><br /></td></tr>
<tr class="separator:ab418f8b63a1b1ed89a04ea1cd566a31e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc0b088ee8b84a0f2fbd4fab3177b10"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#a6bc0b088ee8b84a0f2fbd4fab3177b10">OBJECT_cmp_is_sup_equal</a> (const <a class="el" href="structobject__t.html">object</a> a, const <a class="el" href="structobject__t.html">object</a> b, int *flag)</td></tr>
<tr class="memdesc:a6bc0b088ee8b84a0f2fbd4fab3177b10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renvoie a &gt;= b.  <a href="#a6bc0b088ee8b84a0f2fbd4fab3177b10">Plus de détails...</a><br /></td></tr>
<tr class="separator:a6bc0b088ee8b84a0f2fbd4fab3177b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae53685d941d31264064ddb7bad1b2e9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#aae53685d941d31264064ddb7bad1b2e9">OBJECT_cmp_is_inf_equal</a> (const <a class="el" href="structobject__t.html">object</a> a, const <a class="el" href="structobject__t.html">object</a> b, int *flag)</td></tr>
<tr class="memdesc:aae53685d941d31264064ddb7bad1b2e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renvoie a &lt;= b.  <a href="#aae53685d941d31264064ddb7bad1b2e9">Plus de détails...</a><br /></td></tr>
<tr class="separator:aae53685d941d31264064ddb7bad1b2e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a213abc602996ba1343347dde5d4d6722"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#a213abc602996ba1343347dde5d4d6722">OBJECT_cmp_is_equal</a> (const <a class="el" href="structobject__t.html">object</a> a, const <a class="el" href="structobject__t.html">object</a> b, int *flag)</td></tr>
<tr class="memdesc:a213abc602996ba1343347dde5d4d6722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare deux SFS_NUMBER. Renvoie 1 si égaux 0 sinon.  <a href="#a213abc602996ba1343347dde5d4d6722">Plus de détails...</a><br /></td></tr>
<tr class="separator:a213abc602996ba1343347dde5d4d6722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79151b36db8756df298be886a88dde6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structobject__t.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#a79151b36db8756df298be886a88dde6a">OBJECT_add</a> (const <a class="el" href="structobject__t.html">object</a> a, const <a class="el" href="structobject__t.html">object</a> b, <a class="el" href="structobject__t.html">object</a> result)</td></tr>
<tr class="memdesc:a79151b36db8756df298be886a88dde6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Effectue la somme de 2 objets, écrit résultat dans résult.  <a href="#a79151b36db8756df298be886a88dde6a">Plus de détails...</a><br /></td></tr>
<tr class="separator:a79151b36db8756df298be886a88dde6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a600f7cb500116ca30a31e9ae9c39a469"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structobject__t.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#a600f7cb500116ca30a31e9ae9c39a469">OBJECT_sub</a> (const <a class="el" href="structobject__t.html">object</a> a, const <a class="el" href="structobject__t.html">object</a> b, <a class="el" href="structobject__t.html">object</a> result)</td></tr>
<tr class="memdesc:a600f7cb500116ca30a31e9ae9c39a469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Soustraction de 2 object. Le résultat est mis dans résult.  <a href="#a600f7cb500116ca30a31e9ae9c39a469">Plus de détails...</a><br /></td></tr>
<tr class="separator:a600f7cb500116ca30a31e9ae9c39a469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af66fca655ad9b5fafc4540f7dfc97127"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structobject__t.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#af66fca655ad9b5fafc4540f7dfc97127">OBJECT_mul</a> (const <a class="el" href="structobject__t.html">object</a> a, const <a class="el" href="structobject__t.html">object</a> b, <a class="el" href="structobject__t.html">object</a> result)</td></tr>
<tr class="memdesc:af66fca655ad9b5fafc4540f7dfc97127"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calcul le produit de 2 objects a par b.  <a href="#af66fca655ad9b5fafc4540f7dfc97127">Plus de détails...</a><br /></td></tr>
<tr class="separator:af66fca655ad9b5fafc4540f7dfc97127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2edee12884f9288a6d9f1056f1ecc492"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structobject__t.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#a2edee12884f9288a6d9f1056f1ecc492">OBJECT_div</a> (const <a class="el" href="structobject__t.html">object</a> a, const <a class="el" href="structobject__t.html">object</a> b, <a class="el" href="structobject__t.html">object</a> result)</td></tr>
<tr class="memdesc:a2edee12884f9288a6d9f1056f1ecc492"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calcule la division de a par b.  <a href="#a2edee12884f9288a6d9f1056f1ecc492">Plus de détails...</a><br /></td></tr>
<tr class="separator:a2edee12884f9288a6d9f1056f1ecc492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a122ef0bfddd5435072ae270c9192ee28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structobject__t.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#a122ef0bfddd5435072ae270c9192ee28">OBJECT_modulo</a> (const <a class="el" href="structobject__t.html">object</a> a, const <a class="el" href="structobject__t.html">object</a> b, <a class="el" href="structobject__t.html">object</a> result)</td></tr>
<tr class="memdesc:a122ef0bfddd5435072ae270c9192ee28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calcule ab.  <a href="#a122ef0bfddd5435072ae270c9192ee28">Plus de détails...</a><br /></td></tr>
<tr class="separator:a122ef0bfddd5435072ae270c9192ee28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10043e4705f4650f026a33121cd54815"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structobject__t.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#a10043e4705f4650f026a33121cd54815">OBJECT_quotient</a> (const <a class="el" href="structobject__t.html">object</a> a, const <a class="el" href="structobject__t.html">object</a> b, <a class="el" href="structobject__t.html">object</a> result)</td></tr>
<tr class="memdesc:a10043e4705f4650f026a33121cd54815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calcul la div entière de a par b.  <a href="#a10043e4705f4650f026a33121cd54815">Plus de détails...</a><br /></td></tr>
<tr class="separator:a10043e4705f4650f026a33121cd54815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457357b9ad319b66d3573aaeb2d77933"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#a457357b9ad319b66d3573aaeb2d77933">check_alloc</a> (void *ptr, char *message)</td></tr>
<tr class="memdesc:a457357b9ad319b66d3573aaeb2d77933"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vérifie une allocation dynamique.  <a href="#a457357b9ad319b66d3573aaeb2d77933">Plus de détails...</a><br /></td></tr>
<tr class="separator:a457357b9ad319b66d3573aaeb2d77933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa57b70a35593ee0e9483282f796a5122"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#aa57b70a35593ee0e9483282f796a5122">check_type</a> (<a class="el" href="structobject__t.html">object</a> o, int sfs_type)</td></tr>
<tr class="memdesc:aa57b70a35593ee0e9483282f796a5122"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vérifie que o est bien de type sfs_type.  <a href="#aa57b70a35593ee0e9483282f796a5122">Plus de détails...</a><br /></td></tr>
<tr class="separator:aa57b70a35593ee0e9483282f796a5122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae40aea5d87d9c145bfe576adb9a93f10"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#ae40aea5d87d9c145bfe576adb9a93f10">string_cmp</a> (char *a, char *b)</td></tr>
<tr class="memdesc:ae40aea5d87d9c145bfe576adb9a93f10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare chaine a et b. Renvoie 1 si égale 0 sinon.  <a href="#ae40aea5d87d9c145bfe576adb9a93f10">Plus de détails...</a><br /></td></tr>
<tr class="separator:ae40aea5d87d9c145bfe576adb9a93f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54510b61c6f3490e0d71cbc71cc4225a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#a54510b61c6f3490e0d71cbc71cc4225a">is_form</a> (<a class="el" href="structobject__t.html">object</a> symbol, FORMS *forme)</td></tr>
<tr class="memdesc:a54510b61c6f3490e0d71cbc71cc4225a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renvoie 1 si symbol est un mot clef du langage scheme.  <a href="#a54510b61c6f3490e0d71cbc71cc4225a">Plus de détails...</a><br /></td></tr>
<tr class="separator:a54510b61c6f3490e0d71cbc71cc4225a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8d164b8e7142d98aaff83ccfcd48409"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#aa8d164b8e7142d98aaff83ccfcd48409">check</a> (void *ptr, char *message)</td></tr>
<tr class="memdesc:aa8d164b8e7142d98aaff83ccfcd48409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Si ptr est NULL affiche message dans un warning.  <a href="#aa8d164b8e7142d98aaff83ccfcd48409">Plus de détails...</a><br /></td></tr>
<tr class="separator:aa8d164b8e7142d98aaff83ccfcd48409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe65b3e6071e628e9dd27ceb779a253"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#a0fe65b3e6071e628e9dd27ceb779a253">isealnum</a> (char c)</td></tr>
<tr class="memdesc:a0fe65b3e6071e628e9dd27ceb779a253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vérifie si c est un caractère compatible pour une expression scheme (voir R5RS)  <a href="#a0fe65b3e6071e628e9dd27ceb779a253">Plus de détails...</a><br /></td></tr>
<tr class="separator:a0fe65b3e6071e628e9dd27ceb779a253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8db21bf1c03bc99e813b38a77ff8792e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#a8db21bf1c03bc99e813b38a77ff8792e">wait_first_non_blank_char</a> (char *s1, uint *s1_cursor)</td></tr>
<tr class="memdesc:a8db21bf1c03bc99e813b38a77ff8792e"><td class="mdescLeft">&#160;</td><td class="mdescRight">incrémente le curseur tant qu'il y indique un espace dans la chaine  <a href="#a8db21bf1c03bc99e813b38a77ff8792e">Plus de détails...</a><br /></td></tr>
<tr class="separator:a8db21bf1c03bc99e813b38a77ff8792e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13394f7830becff1f3558b6f5b0969f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structobject__t.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#a13394f7830becff1f3558b6f5b0969f9">ENV_build</a> (<a class="el" href="structobject__t.html">object</a> father)</td></tr>
<tr class="memdesc:a13394f7830becff1f3558b6f5b0969f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construit un environnement dont le père est father.  <a href="#a13394f7830becff1f3558b6f5b0969f9">Plus de détails...</a><br /></td></tr>
<tr class="separator:a13394f7830becff1f3558b6f5b0969f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c450315c9bb5fc8d72fe422bccad428"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structobject__t.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#a6c450315c9bb5fc8d72fe422bccad428">ENV_get_var_in_env</a> (<a class="el" href="structobject__t.html">object</a> var, <a class="el" href="structobject__t.html">object</a> environ, int *flag)</td></tr>
<tr class="memdesc:a6c450315c9bb5fc8d72fe422bccad428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chercher la variable de nom var dans l'environnement environ.  <a href="#a6c450315c9bb5fc8d72fe422bccad428">Plus de détails...</a><br /></td></tr>
<tr class="separator:a6c450315c9bb5fc8d72fe422bccad428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4067fb8e91d359bbdb385e9ec352f6f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structobject__t.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#a4067fb8e91d359bbdb385e9ec352f6f7">ENV_get_var</a> (<a class="el" href="structobject__t.html">object</a> var, int *flag, <a class="el" href="structobject__t.html">object</a> <a class="el" href="repl_8c.html#a062b7366fcc9f920dbb8475d815e0bfc">env</a>)</td></tr>
<tr class="memdesc:a4067fb8e91d359bbdb385e9ec352f6f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cherche le symbole var dans les environnements.  <a href="#a4067fb8e91d359bbdb385e9ec352f6f7">Plus de détails...</a><br /></td></tr>
<tr class="separator:a4067fb8e91d359bbdb385e9ec352f6f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5e97aa15404862a8399b65de323e79a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structobject__t.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#aa5e97aa15404862a8399b65de323e79a">ENV_add_var</a> (<a class="el" href="structobject__t.html">object</a> name, <a class="el" href="structobject__t.html">object</a> value, <a class="el" href="structobject__t.html">object</a> <a class="el" href="repl_8c.html#a062b7366fcc9f920dbb8475d815e0bfc">env</a>)</td></tr>
<tr class="memdesc:aa5e97aa15404862a8399b65de323e79a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ajoute la variable de nom name et de valeur value l'environnement courant.  <a href="#aa5e97aa15404862a8399b65de323e79a">Plus de détails...</a><br /></td></tr>
<tr class="separator:aa5e97aa15404862a8399b65de323e79a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2df9f8fb71e31bff32346db4f05c0b26"><td class="memItemLeft" align="right" valign="top"><a id="a2df9f8fb71e31bff32346db4f05c0b26"></a>
<a class="el" href="structobject__t.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ENV_update_var</b> (<a class="el" href="structobject__t.html">object</a> name, const <a class="el" href="structobject__t.html">object</a> val, <a class="el" href="structobject__t.html">object</a> <a class="el" href="repl_8c.html#a062b7366fcc9f920dbb8475d815e0bfc">env</a>)</td></tr>
<tr class="separator:a2df9f8fb71e31bff32346db4f05c0b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fb587a2ac0a4bebac5317ece2968594"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#a7fb587a2ac0a4bebac5317ece2968594">ENV_check_loop</a> (<a class="el" href="structobject__t.html">object</a> name)</td></tr>
<tr class="memdesc:a7fb587a2ac0a4bebac5317ece2968594"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vérifie la validité d'un environnement.  <a href="#a7fb587a2ac0a4bebac5317ece2968594">Plus de détails...</a><br /></td></tr>
<tr class="separator:a7fb587a2ac0a4bebac5317ece2968594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefcd2aa34b5206d99869c3df1e292cc8"><td class="memItemLeft" align="right" valign="top">compound&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#aefcd2aa34b5206d99869c3df1e292cc8">COMP_build_empty</a> ()</td></tr>
<tr class="memdesc:aefcd2aa34b5206d99869c3df1e292cc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construit un agrégat vide.  <a href="#aefcd2aa34b5206d99869c3df1e292cc8">Plus de détails...</a><br /></td></tr>
<tr class="separator:aefcd2aa34b5206d99869c3df1e292cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f0fc998b6f930d64cdd92ca8fecb90"><td class="memItemLeft" align="right" valign="top">compound&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#a24f0fc998b6f930d64cdd92ca8fecb90">COMP_build</a> (<a class="el" href="structobject__t.html">object</a> param, <a class="el" href="structobject__t.html">object</a> body, <a class="el" href="structobject__t.html">object</a> envt)</td></tr>
<tr class="memdesc:a24f0fc998b6f930d64cdd92ca8fecb90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construit un compound avec les arguments donnés.  <a href="#a24f0fc998b6f930d64cdd92ca8fecb90">Plus de détails...</a><br /></td></tr>
<tr class="separator:a24f0fc998b6f930d64cdd92ca8fecb90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea04d47288e13db0b8bebfcd1fe1042"><td class="memItemLeft" align="right" valign="top">compound&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#a6ea04d47288e13db0b8bebfcd1fe1042">COMP_set</a> (compound *a, <a class="el" href="structobject__t.html">object</a> param, <a class="el" href="structobject__t.html">object</a> body, <a class="el" href="structobject__t.html">object</a> envt)</td></tr>
<tr class="memdesc:a6ea04d47288e13db0b8bebfcd1fe1042"><td class="mdescLeft">&#160;</td><td class="mdescRight">Met à jour le compound a.  <a href="#a6ea04d47288e13db0b8bebfcd1fe1042">Plus de détails...</a><br /></td></tr>
<tr class="separator:a6ea04d47288e13db0b8bebfcd1fe1042"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Description détaillée</h2>
<div class="textblock"><p>Fonctions relatives à la structure object. </p>
<dl class="section author"><dt>Auteur</dt><dd>François Cayre &lt;cayre.(null)&gt; and Rimbaud Sébastien <a href="#" onclick="location.href='mai'+'lto:'+'seb'+'as'+'tie'+'n.'+'rim'+'ba'+'ud@'+'ph'+'elm'+'a.'+'gre'+'no'+'ble'+'-i'+'np.'+'fr'; return false;">sebas<span style="display: none;">.nosp@m.</span>tien<span style="display: none;">.nosp@m.</span>.rimb<span style="display: none;">.nosp@m.</span>aud@<span style="display: none;">.nosp@m.</span>phelm<span style="display: none;">.nosp@m.</span>a.gr<span style="display: none;">.nosp@m.</span>enobl<span style="display: none;">.nosp@m.</span>e-in<span style="display: none;">.nosp@m.</span>p.fr</a> </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Sun September 2016 16:35 Contient toutes les fonctions permettant de manipuler (affichage, édition) de la structure object. Contient également les fonctions de création de NIL, TRUE et FALSE. </dd></dl>
</div><h2 class="groupheader">Documentation des fonctions</h2>
<a id="aa8d164b8e7142d98aaff83ccfcd48409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8d164b8e7142d98aaff83ccfcd48409">&sect;&nbsp;</a></span>check()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int check </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Si ptr est NULL affiche message dans un warning. </p>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie 0 si ptr==NULL </dd></dl>

</div>
</div>
<a id="a457357b9ad319b66d3573aaeb2d77933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a457357b9ad319b66d3573aaeb2d77933">&sect;&nbsp;</a></span>check_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void check_alloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vérifie une allocation dynamique. </p>
<p>Quitte le programme avec un ERROR_MSG si une alloc rate. </p>

</div>
</div>
<a id="aa57b70a35593ee0e9483282f796a5122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa57b70a35593ee0e9483282f796a5122">&sect;&nbsp;</a></span>check_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int check_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sfs_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vérifie que o est bien de type sfs_type. </p>
<p>Renvoie 0 si o NULL. </p><dl class="section return"><dt>Renvoie</dt><dd>Renvoie 1 si o est de type sfs_type, 0 sinon. </dd></dl>

</div>
</div>
<a id="a24f0fc998b6f930d64cdd92ca8fecb90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24f0fc998b6f930d64cdd92ca8fecb90">&sect;&nbsp;</a></span>COMP_build()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">compound COMP_build </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>envt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construit un compound avec les arguments donnés. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">param</td><td>: les paramètres de la fonction </td></tr>
    <tr><td class="paramname">body</td><td>: Les instructions de la fonction. </td></tr>
    <tr><td class="paramname">envt</td><td>: L'environnement dans lequel est définit le compound.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoit le compound construit. </dd></dl>

</div>
</div>
<a id="aefcd2aa34b5206d99869c3df1e292cc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefcd2aa34b5206d99869c3df1e292cc8">&sect;&nbsp;</a></span>COMP_build_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">compound COMP_build_empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construit un agrégat vide. </p>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie l'agrégat construit. </dd></dl>

</div>
</div>
<a id="a6ea04d47288e13db0b8bebfcd1fe1042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ea04d47288e13db0b8bebfcd1fe1042">&sect;&nbsp;</a></span>COMP_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">compound COMP_set </td>
          <td>(</td>
          <td class="paramtype">compound *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>envt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Met à jour le compound a. </p>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie le compound mis à jour. </dd></dl>

</div>
</div>
<a id="aa5e97aa15404862a8399b65de323e79a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5e97aa15404862a8399b65de323e79a">&sect;&nbsp;</a></span>ENV_add_var()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structobject__t.html">object</a> ENV_add_var </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ajoute la variable de nom name et de valeur value l'environnement courant. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>: Nom de la variable (symbole) </td></tr>
    <tr><td class="paramname">value</td><td>: valeur de la variable.</td></tr>
  </table>
  </dd>
</dl>
<p>Ajoute la variable de nom name et de valeur value à l'environnement courant. Si jamais elle existe déjà elle reçoit une nouvelle valeur. Renvoie NULL et affiche un warning si name n'est pas un symbole. Renvoie NULL et affiche un warning si value est de type SFS_ENV. Dans les 2 précédents cas quitte la fonction prématurément sans effectuer d'actions.</p>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie la valeur de la variable crée. </dd></dl>
<p>On fait un ajout tête en gros ! </p>

</div>
</div>
<a id="a13394f7830becff1f3558b6f5b0969f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13394f7830becff1f3558b6f5b0969f9">&sect;&nbsp;</a></span>ENV_build()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structobject__t.html">object</a> ENV_build </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>father</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construit un environnement dont le père est father. </p>
<p>L'environnement construit possède comme parent father. Si father est mis à nul, construit un top-level.</p>
<dl class="section return"><dt>Renvoie</dt><dd></dd></dl>

</div>
</div>
<a id="a7fb587a2ac0a4bebac5317ece2968594"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fb587a2ac0a4bebac5317ece2968594">&sect;&nbsp;</a></span>ENV_check_loop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ENV_check_loop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vérifie la validité d'un environnement. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>: Variable que l'on souhaite vérifier.</td></tr>
  </table>
  </dd>
</dl>
<p>Vérifie qu'un environnement en présente pas d'incohérences comme des appels circulaires de variable :<br />
x-&gt;y-&gt;z-&gt;x-&gt;y... .</p>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000002">Bogue:</a></b></dt><dd>Obsolete, implémentation mauvaise.</dd></dl>
<dl class="section return"><dt>Renvoie</dt><dd>0 si incohérences trouvées, 1 sinon. </dd></dl>

</div>
</div>
<a id="a4067fb8e91d359bbdb385e9ec352f6f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4067fb8e91d359bbdb385e9ec352f6f7">&sect;&nbsp;</a></span>ENV_get_var()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structobject__t.html">object</a> ENV_get_var </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cherche le symbole var dans les environnements. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">var</td><td>: Symbole à chercher.  flat : Drapeau pour savoir s'il est trouvé. Mis à 1 si trouvé.</td></tr>
  </table>
  </dd>
</dl>
<p>Cherche la variable var dans les environnements. Si var n'est pas un symbole cette fonction affiche un warning et renvoie var. Retourne la première occurrence de le variable dans l'environnement courant. Si elle n'est pas trouvée il cherche dans les pères jusqu'à trouver la première occurrence de la variable. Si jamais il ne la trouve pas il renvoie NULL. S'il trouve le symbole le flag est mis à 1.</p>
<dl class="section see"><dt>Voir également</dt><dd><a class="el" href="object_8c.html#a6c450315c9bb5fc8d72fe422bccad428" title="Chercher la variable de nom var dans l&#39;environnement environ. ">ENV_get_var_in_env</a></dd></dl>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie une paire dont le car porte le nom de la variable et le cdr sa valeur. </dd></dl>

</div>
</div>
<a id="a6c450315c9bb5fc8d72fe422bccad428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c450315c9bb5fc8d72fe422bccad428">&sect;&nbsp;</a></span>ENV_get_var_in_env()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structobject__t.html">object</a> ENV_get_var_in_env </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>environ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Chercher la variable de nom var dans l'environnement environ. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">var</td><td>: Nom de la variable que l'on cherche. </td></tr>
    <tr><td class="paramname">environ</td><td>: Environnement dans lequel on cherche </td></tr>
    <tr><td class="paramname">flag</td><td>: Mis à vrai si on a trouvé. Retourne la première occurrence de le variable dans l'environnement courant. Renvoie une pair dont le car porte le nom de la variable et le cdr porte sa valeur. Si jamais il ne la trouve pas il passe le flag à false. S'il trouve il le met à TRUE.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie une paire dont le car porte le nom de la variable (symbole) et le cdr sa valeur. </dd></dl>

</div>
</div>
<a id="a54510b61c6f3490e0d71cbc71cc4225a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54510b61c6f3490e0d71cbc71cc4225a">&sect;&nbsp;</a></span>is_form()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int is_form </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>symbol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FORMS *&#160;</td>
          <td class="paramname"><em>forme</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renvoie 1 si symbol est un mot clef du langage scheme. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">symbol</td><td>: Le symbole dont on veut savoir si c'est une forme. </td></tr>
    <tr><td class="paramname">forme</td><td>: Pointeur qui est met à jour pour connaitre la forme dans la variable globale form[].</td></tr>
  </table>
  </dd>
</dl>
<p>Vérifie si symbol est un mot clef du langage. Met à jour forme sur le bon numéro de la forme. Renvoie 1 si c'est le cas 0 sinon. Peut recevoir forme égale à NULL.</p>
<dl class="section see"><dt>Voir également</dt><dd><a class="el" href="object_8c.html#aabab05a704acf24c0040b7223908c858" title="Initialise formes de l&#39;interpréteur. ">make_forms()</a> </dd>
<dd>
NB_FORMS</dd></dl>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie 1 si c'est une forme, 0 sinon. </dd></dl>

</div>
</div>
<a id="a0fe65b3e6071e628e9dd27ceb779a253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fe65b3e6071e628e9dd27ceb779a253">&sect;&nbsp;</a></span>isealnum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int isealnum </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vérifie si c est un caractère compatible pour une expression scheme (voir R5RS) </p>
<p>Les caractères compatibles sont [a-z] [A-Z] [0-9] et ! $ * = + - . / : &lt; &gt; ? @ &amp; % : ^ _ ~.</p>
<dl class="section see"><dt>Voir également</dt><dd><a href="https://linux.die.net/man/3/isalnum ">isalnum </a> </dd></dl>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie 1 si c est compatible 0 sinon. </dd></dl>

</div>
</div>
<a id="a0c208c0fbec6ecf85e3de7949b7691cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c208c0fbec6ecf85e3de7949b7691cf">&sect;&nbsp;</a></span>make_false()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structobject__t.html">object</a> make_false </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Créé le booléen faux (variable globale). Fonction appelée dans <a class="el" href="repl_8c.html#ac7892fa748bffcd6854f8b7adeb40ba0" title="Initialise les variables globales de l&#39;interpréteur. ">init_interpreter()</a>. </p>
<p>Cette fonction quitte l'interpréteur si l'allocation échoue. Inutile de continuer si le booléen n'existe pas dans l'interpréteur. L'objet vrai est de type SFS_BOOLEAN et possède son this.number mis à 0. </p>

</div>
</div>
<a id="aabab05a704acf24c0040b7223908c858"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabab05a704acf24c0040b7223908c858">&sect;&nbsp;</a></span>make_forms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void make_forms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise formes de l'interpréteur. </p>
<dl class="section see"><dt>Voir également</dt><dd>FORMS; </dd></dl>

</div>
</div>
<a id="a0175150d600f632a2675d80b72823f45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0175150d600f632a2675d80b72823f45">&sect;&nbsp;</a></span>make_nil()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structobject__t.html">object</a> make_nil </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alloue l'objet nil qui marque fin de o. Programme se termine si l'alloc rate. </p>
<p>Le programme se termine si la création de l'objet nil rate. En effet cet objet étant utilisé pour toutes <br />
les listes scheme, un échec de sa création empêchera inévitablement le bon fonctionnement de l'interpréteur.</p>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie un pointeur sur l'objet créé. </dd></dl>

</div>
</div>
<a id="ae588b0336388f82cf984bca34a66fe99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae588b0336388f82cf984bca34a66fe99">&sect;&nbsp;</a></span>make_object()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structobject__t.html">object</a> make_object </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alloue un objet de type type, vérifie l'alloc. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>: type de l'objet (num, char, string , string (symbol), PAIR, special (nil)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie un pointeur sur l'objet créé. </dd></dl>

</div>
</div>
<a id="aa54a323be37760f91b9a423760d800d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa54a323be37760f91b9a423760d800d3">&sect;&nbsp;</a></span>make_true()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structobject__t.html">object</a> make_true </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Créé le booléen vrai (variable globale). Fonction appelée dans <a class="el" href="repl_8c.html#ac7892fa748bffcd6854f8b7adeb40ba0" title="Initialise les variables globales de l&#39;interpréteur. ">init_interpreter()</a>. </p>
<p>Cette fonction quitte l'interpréteur si l'allocation échoue. Inutile de continuer si le booléen n'existe pas dans l'interpréteur. L'objet vrai est de type SFS_BOOLEAN et possède son this.number mis à 1. </p>

</div>
</div>
<a id="a79151b36db8756df298be886a88dde6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79151b36db8756df298be886a88dde6a">&sect;&nbsp;</a></span>OBJECT_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structobject__t.html">object</a> OBJECT_add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Effectue la somme de 2 objets, écrit résultat dans résult. </p>
<p>La somme est faite sur des objects de type SFS_NUM. Le résultat est écrit dans result et result est retourné. Il faut toujours prendre la valeur retournée par la fonction, result permet d'éviter un trop grand nombre d'allocation dans PRIM_somme. Retourne nil si la somme est irréalisable (Utile pour les affectations).</p>
<dl class="section see"><dt>Voir également</dt><dd><a class="el" href="number_8c.html#aa001b3a988a911dfb8b9db6c716f47a4" title="Effectue la somme de 2 num. ">NUM_sum</a></dd></dl>
<dl class="section return"><dt>Renvoie</dt><dd>Retourne le résultat de la somme ou nil si erreur. </dd></dl>

</div>
</div>
<a id="a09933fca31b4b68d1e8d1d8f26f7ce45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09933fca31b4b68d1e8d1d8f26f7ce45">&sect;&nbsp;</a></span>OBJECT_build_cpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structobject__t.html">object</a> OBJECT_build_cpy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copie l'objet o en en allouant un nouveau. </p>
<p>Si l'objet est nil ou un booléen on ne refait pas d'alloc on renvoie la variable globale correspondante. Si l'objet est NULL renvoie null et affiche un warning.</p>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie l'objet créé. </dd></dl>

</div>
</div>
<a id="ade583a8335577c269af8b9cc37567699"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade583a8335577c269af8b9cc37567699">&sect;&nbsp;</a></span>OBJECT_build_pair()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structobject__t.html">object</a> OBJECT_build_pair </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>car</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>cdr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construit une paire avec un car et cdr donné. </p>
<p>Construit une liste avec un car et cdr donné. Si car ou cdr == NULL alors il seront mis à nil.</p>
<dl class="section see"><dt>Voir également</dt><dd><a class="el" href="object_8c.html#a4d4c460873067cf00d877f60cdd285ec" title="Met à jour le cdr de o avec l&#39;object cdr. ">OBJECT_set_cdr(object o, object car)</a> </dd>
<dd>
<a class="el" href="object_8c.html#a8ccb3f30397a60a9d663f43c4dc28514" title="Met à jour le car de o avec l&#39;objet car. ">OBJECT_set_car(object o, object car)</a></dd></dl>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie un object avec car et le cdr donné. </dd></dl>

</div>
</div>
<a id="aba2f19194908157a74d7250b28929484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba2f19194908157a74d7250b28929484">&sect;&nbsp;</a></span>OBJECT_build_symbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structobject__t.html">object</a> OBJECT_build_symbol </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>symbol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construit un object de type symbole contenant symbole. </p>
<p>Doit contenir 256 caractère définit pas string et STRLEN.</p>
<dl class="section return"><dt>Renvoie</dt><dd></dd></dl>

</div>
</div>
<a id="a1d783570ac14dc2efa3f0565e162a6e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d783570ac14dc2efa3f0565e162a6e8">&sect;&nbsp;</a></span>OBJECT_built_short_quote()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structobject__t.html">object</a> OBJECT_built_short_quote </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>here</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construit le début de pair pour quote sous forme '. </p>
<p>Lorsque que l'on a '(objects) cette fonction construit l'object équivalent à (quote (object)) Elle appelle sfs_read sur le reste de la liste.</p>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie une forme quote. </dd></dl>

</div>
</div>
<a id="a8467e456f150c3514808c26c6864497d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8467e456f150c3514808c26c6864497d">&sect;&nbsp;</a></span>OBJECT_cmp_bool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OBJECT_cmp_bool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare 2 booléens. Renvoie 0 s'ils ne sont pas booléens. </p>
<dl class="section return"><dt>Renvoie</dt><dd>1 si les 2 booléens sont égaux, 0 sinon. </dd></dl>

</div>
</div>
<a id="a213abc602996ba1343347dde5d4d6722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a213abc602996ba1343347dde5d4d6722">&sect;&nbsp;</a></span>OBJECT_cmp_is_equal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OBJECT_cmp_is_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare deux SFS_NUMBER. Renvoie 1 si égaux 0 sinon. </p>
<p>Compare a et b en les considérant comme entier. Si a ou b n'est pas entier le flag passe à 1 et elle renvoie 0. Deux infinis de même signe ne sont pas considéré comme égaux.</p>
<dl class="section see"><dt>Voir également</dt><dd><a class="el" href="object_8c.html#aa8a7c4f6341e5477c8cf12d9fa4b8048" title="Compare deux objets de type SFS_NUMBER. ">OBJECT_cmp_number</a> </dd>
<dd>
<a class="el" href="number_8c.html#a6277368742d428b9aacacc45280643a5" title="Renvoie a==b. ">NUM_is_equal</a></dd></dl>
<dl class="section return"><dt>Renvoie</dt><dd></dd></dl>

</div>
</div>
<a id="ab4b6a20ced958c8d2f5fda6c0e8f191b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4b6a20ced958c8d2f5fda6c0e8f191b">&sect;&nbsp;</a></span>OBJECT_cmp_is_inf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OBJECT_cmp_is_inf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renvoie a &lt; b. </p>
<p>Si a ou b ne sont pas des SFS_NUMBER renvoie 0 et affiche un warning. Le flag est mis à 1. Si il y a une erreur dans le calcul, flag mis à 1.</p>
<dl class="section see"><dt>Voir également</dt><dd><a class="el" href="number_8c.html#aeecb8abee811d7a6fd66294707a6aef7" title="Renvoie a &lt; b. ">NUM_is_inf</a></dd></dl>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie a &lt; b, O si erreur alors flag mis à 1. </dd></dl>

</div>
</div>
<a id="aae53685d941d31264064ddb7bad1b2e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae53685d941d31264064ddb7bad1b2e9">&sect;&nbsp;</a></span>OBJECT_cmp_is_inf_equal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OBJECT_cmp_is_inf_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renvoie a &lt;= b. </p>
<dl class="section see"><dt>Voir également</dt><dd>OBJECT_is_cmp_inf </dd>
<dd>
<a class="el" href="number_8c.html#aa80212b266cf3e9ea95b1687faa851dc" title="Renvoie a &lt;= b. ">NUM_is_inf_equal</a> </dd></dl>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie a &lt;= b, 0 si erreur alors flag mis à 1. </dd></dl>

</div>
</div>
<a id="ab418f8b63a1b1ed89a04ea1cd566a31e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab418f8b63a1b1ed89a04ea1cd566a31e">&sect;&nbsp;</a></span>OBJECT_cmp_is_sup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OBJECT_cmp_is_sup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renvoie a &gt; b. </p>
<dl class="section see"><dt>Voir également</dt><dd>OBJECT_is_cmp_inf </dd>
<dd>
<a class="el" href="number_8c.html#a59ace3e4546feb54fbe6adc2aebc43b7" title="renvoie a &gt; b. ">NUM_is_sup</a></dd></dl>
<dl class="section return"><dt>Renvoie</dt><dd>a &gt; b, 0 si erreur alors flag mis à 1. </dd></dl>

</div>
</div>
<a id="a6bc0b088ee8b84a0f2fbd4fab3177b10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bc0b088ee8b84a0f2fbd4fab3177b10">&sect;&nbsp;</a></span>OBJECT_cmp_is_sup_equal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OBJECT_cmp_is_sup_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renvoie a &gt;= b. </p>
<dl class="section see"><dt>Voir également</dt><dd>OBJECT_is_cmp_inf </dd>
<dd>
<a class="el" href="number_8c.html#a82f3036db60fc9e814e4648e37b725a2" title="Renvoie a &gt;= b. ">NUM_is_sup_equal</a></dd></dl>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie a &gt;= b, 0 sinon, si erreur flag mis à 1. </dd></dl>

</div>
</div>
<a id="aa8a7c4f6341e5477c8cf12d9fa4b8048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8a7c4f6341e5477c8cf12d9fa4b8048">&sect;&nbsp;</a></span>OBJECT_cmp_number()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OBJECT_cmp_number </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare deux objets de type SFS_NUMBER. </p>
<dl class="section see"><dt>Voir également</dt><dd><a class="el" href="number_8c.html#aba35ad055dd8fd8e71bd2d7bc69a3cad" title="Compare deux num. Renvoie 1 si égaux, 0 sinon. ">NUM_cmp</a> </dd>
<dd>
<a class="el" href="object_8c.html#a213abc602996ba1343347dde5d4d6722" title="Compare deux SFS_NUMBER. Renvoie 1 si égaux 0 sinon. ">OBJECT_cmp_is_equal</a> </dd></dl>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie 1 si a et b contiennent les mêmes entiers. 0 sinon. </dd></dl>

</div>
</div>
<a id="a85b5035114247cba825eafb2ef1d34c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85b5035114247cba825eafb2ef1d34c0">&sect;&nbsp;</a></span>OBJECT_cmp_symb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OBJECT_cmp_symb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>symbol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare a avec le symbol symbol. </p>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie 1 si égaux, O sinon. </dd></dl>

</div>
</div>
<a id="a5f88c49537b92e95b7d33660446ee8c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f88c49537b92e95b7d33660446ee8c7">&sect;&nbsp;</a></span>OBJECT_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OBJECT_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a> *&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supprime un objet. </p>
<p>Supprime tous les éléments d'un objet si c'est une paire, de même pour un environnement. <br />
Fonction a modifier si on alloue dynamiquement les string et symboles. Pour l'instant c'est un free classique. Voir le pb sur les booléens aussi. </p>

</div>
</div>
<a id="ad1356f35f47fdbb828bc06a5884d74ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1356f35f47fdbb828bc06a5884d74ed">&sect;&nbsp;</a></span>OBJECT_destroy_pair()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OBJECT_destroy_pair </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a> *&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supprime une paire. Fonction récursive. </p>
<p>Pas de controle sur o pour savoir si c'est bien une paire. Fonction appelée par OBJECT_destroy. N'utiliser que OBJECT_destroy pas celle-ci, elle n'est utile qu'à l'implémentation du destructeur général. </p>

</div>
</div>
<a id="a2edee12884f9288a6d9f1056f1ecc492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2edee12884f9288a6d9f1056f1ecc492">&sect;&nbsp;</a></span>OBJECT_div()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structobject__t.html">object</a> OBJECT_div </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calcule la division de a par b. </p>
<dl class="section see"><dt>Voir également</dt><dd><a class="el" href="object_8c.html#a79151b36db8756df298be886a88dde6a" title="Effectue la somme de 2 objets, écrit résultat dans résult. ">OBJECT_add</a> </dd>
<dd>
<a class="el" href="number_8c.html#a33c7fe283eec368735c8619468ccaeb9" title="Calcule a/b. ">NUM_div</a></dd></dl>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie result mis à jour. Nil si erreur. </dd></dl>

</div>
</div>
<a id="a486b361de0c6c18f7227158b12dbfd4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a486b361de0c6c18f7227158b12dbfd4a">&sect;&nbsp;</a></span>OBJECT_get_cxr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structobject__t.html">object</a> OBJECT_get_cxr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>place</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renvoie de l'élement de la pair correspondant à la chaine. </p>
<p>Renvoie l'élément car si la chaine "car" est donnée. Renvoie l'élément cdr si la chaine "cdr" est donnée. Renvoie le car du cdr si la chaine "cadr" est donnée. Lis la chaine à l'envers et prend le cdr si d est donné ou le car si a est donnée. Le format d'entré doit contenir en première lettre un c en dernière un r. En pratique si d'autres lettres sont placées la fonction ne fera pas la différence car elle les ignore. Au milieu on aura que des a et des d. Si on trouve une autre lettre affiche un warning et retourne NULL. Si on spécifie une location inexistante dans la paire la fonction affiche un warning et renvoie NULL. Si o n'est pas une paire, revoie NULL. Si dans le parcours on croise un élément qui n'est pas une paire, on renvoie NULL avec WARNING_MSG.</p>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie l'objet lu correspondant à la chaine. </dd></dl>

</div>
</div>
<a id="a0d7084a07b321423f9cd922529fd8ed8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d7084a07b321423f9cd922529fd8ed8">&sect;&nbsp;</a></span>OBJECT_isempty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OBJECT_isempty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vérifie si un objet est vide (égal à NULL) </p>
<dl class="section return"><dt>Renvoie</dt><dd>Vrai si vide, faux sinon. </dd></dl>

</div>
</div>
<a id="ab49b1649bad38a97c44b7713731cea48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab49b1649bad38a97c44b7713731cea48">&sect;&nbsp;</a></span>OBJECT_isEqual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OBJECT_isEqual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare deux object Renvoie 1 s'ils sont égaux 0 sinon. </p>
<p>Deux objets sont considérés comme égaux s'ils ont le même type et la même valeur.</p>
<dl class="section return"><dt>Renvoie</dt><dd>1 si a==b, 0 sinon. </dd></dl>

</div>
</div>
<a id="a122ef0bfddd5435072ae270c9192ee28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a122ef0bfddd5435072ae270c9192ee28">&sect;&nbsp;</a></span>OBJECT_modulo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structobject__t.html">object</a> OBJECT_modulo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calcule ab. </p>
<p>Fonctionnement similaire à OBJECT_add. </p><dl class="section see"><dt>Voir également</dt><dd><a class="el" href="object_8c.html#a79151b36db8756df298be886a88dde6a" title="Effectue la somme de 2 objets, écrit résultat dans résult. ">OBJECT_add</a> </dd>
<dd>
<a class="el" href="number_8c.html#a99f71152b0d68cb8843d84e7af1bfc31" title="Calcule ab. ">NUM_modulo</a></dd></dl>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie le résultat. </dd></dl>

</div>
</div>
<a id="af66fca655ad9b5fafc4540f7dfc97127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af66fca655ad9b5fafc4540f7dfc97127">&sect;&nbsp;</a></span>OBJECT_mul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structobject__t.html">object</a> OBJECT_mul </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calcul le produit de 2 objects a par b. </p>
<p>A priori, le produit ne pose pas d'impossibilité de calcul, que ce soit un nombre ou un infini on peut toujours calculer le produit et trouver un résultat.</p>
<dl class="section see"><dt>Voir également</dt><dd><a class="el" href="object_8c.html#a79151b36db8756df298be886a88dde6a" title="Effectue la somme de 2 objets, écrit résultat dans résult. ">OBJECT_add</a> </dd>
<dd>
<a class="el" href="number_8c.html#ad7003e02f06ef1fd25a160c3b0a5b880" title="Produit de a par b. ">NUM_mul</a></dd></dl>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie le result mis à jour si produit possible, nil sinon. </dd></dl>

</div>
</div>
<a id="a10043e4705f4650f026a33121cd54815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10043e4705f4650f026a33121cd54815">&sect;&nbsp;</a></span>OBJECT_quotient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structobject__t.html">object</a> OBJECT_quotient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calcul la div entière de a par b. </p>
<p>Si a et b non SFS_NUMBER renvoie NULL. Si a et b non entier renvoie NULL</p>
<p>Similaire a OBJECT_add.</p>
<dl class="section see"><dt>Voir également</dt><dd><a class="el" href="object_8c.html#a79151b36db8756df298be886a88dde6a" title="Effectue la somme de 2 objets, écrit résultat dans résult. ">OBJECT_add</a> </dd>
<dd>
<a class="el" href="number_8c.html#a52d0aa57fb2da6f67cd8f0ce42ed7454" title="Calcule a/b pour des entiers. ">NUM_quotient</a></dd></dl>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie le result mis à jour. </dd></dl>

</div>
</div>
<a id="a64f2fee85ada6041d0c74a250c419686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64f2fee85ada6041d0c74a250c419686">&sect;&nbsp;</a></span>OBJECT_rewrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OBJECT_rewrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>changed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>nouveau</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Réécris avec la valeur de nouveau. </p>
<p>Attention si changed est de type SFS_NIL, un nouvel objet est renvoyé. </p><dl class="bug"><dt><b><a class="el" href="bug.html#_bug000001">Bogue:</a></b></dt><dd>Incomplète</dd></dl>

</div>
</div>
<a id="a8ccb3f30397a60a9d663f43c4dc28514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ccb3f30397a60a9d663f43c4dc28514">&sect;&nbsp;</a></span>OBJECT_set_car()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OBJECT_set_car </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>car</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Met à jour le car de o avec l'objet car. </p>
<p>Si car est NULL place la variable globale nil. Si jamais o n'est pas une paire ni un environnement ne fait rien et affiche un warning. </p>

</div>
</div>
<a id="a4d4c460873067cf00d877f60cdd285ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d4c460873067cf00d877f60cdd285ec">&sect;&nbsp;</a></span>OBJECT_set_cdr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OBJECT_set_cdr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>cdr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Met à jour le cdr de o avec l'object cdr. </p>
<p>Si cdr est a NULL place la variable globale nil. Si o n'est pas une paire ni un environnement ne fait rien et affiche un warning. </p>

</div>
</div>
<a id="a421310d9e2d05d70789086bd9418656c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a421310d9e2d05d70789086bd9418656c">&sect;&nbsp;</a></span>OBJECT_set_cxr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OBJECT_set_cxr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>place</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modifie l'emplacement donné et y met la variable val. </p>
<p>Cette fonction ne libère pas l'ancienne valeur. L'objet à ajouter doit-être préalablement alloué. Ne fait rien si o est a NULL. Ajoute nil si val est a NULL avec un appel récursif.</p>
<dl class="section see"><dt>Voir également</dt><dd><a class="el" href="object_8c.html#a5f88c49537b92e95b7d33660446ee8c7" title="Supprime un objet. ">OBJECT_destroy</a> </dd>
<dd>
<a class="el" href="object_8c.html#a486b361de0c6c18f7227158b12dbfd4a" title="Renvoie de l&#39;élement de la pair correspondant à la chaine. ">OBJECT_get_cxr</a></dd></dl>
<dl class="section return"><dt>Renvoie</dt><dd></dd></dl>

</div>
</div>
<a id="a600f7cb500116ca30a31e9ae9c39a469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a600f7cb500116ca30a31e9ae9c39a469">&sect;&nbsp;</a></span>OBJECT_sub()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structobject__t.html">object</a> OBJECT_sub </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Soustraction de 2 object. Le résultat est mis dans résult. </p>
<p>Fonctionnement similaire à OBJECT_add. </p><dl class="section see"><dt>Voir également</dt><dd><a class="el" href="object_8c.html#a79151b36db8756df298be886a88dde6a" title="Effectue la somme de 2 objets, écrit résultat dans résult. ">OBJECT_add</a> </dd>
<dd>
<a class="el" href="number_8c.html#a7790d6469a5253d77a41fe3066d69cb7" title="Calcul a - b. ">NUM_sub</a></dd></dl>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie result mis à jour si opération possible, nil sinon. </dd></dl>

</div>
</div>
<a id="ae40aea5d87d9c145bfe576adb9a93f10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae40aea5d87d9c145bfe576adb9a93f10">&sect;&nbsp;</a></span>string_cmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int string_cmp </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare chaine a et b. Renvoie 1 si égale 0 sinon. </p>
<p>Si les chaines n'ont pas la même longueur renvoie 0. Compare les chaines avec strncmp.</p>
<dl class="section return"><dt>Renvoie</dt><dd>1 si chaine égales, 0 sinon. </dd></dl>

</div>
</div>
<a id="a8db21bf1c03bc99e813b38a77ff8792e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8db21bf1c03bc99e813b38a77ff8792e">&sect;&nbsp;</a></span>wait_first_non_blank_char()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wait_first_non_blank_char </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>s1_cursor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>incrémente le curseur tant qu'il y indique un espace dans la chaine </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>: Chaine dans laquelle on veut sauter les espaces. </td></tr>
    <tr><td class="paramname">s1_cursor</td><td>: Curseur dans la chaine.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>Voir également</dt><dd><a href="https://linux.die.net/man/3/isspace">isspace </a> </dd></dl>
<dl class="section return"><dt>Renvoie</dt><dd>: Renvoie le premier indice qui n'est pas un espace. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Généré par &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.12
</small></address>
</body>
</html>
