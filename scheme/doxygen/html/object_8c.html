<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Livrable3 Informatique Phelma SICOM: Référence du fichier src/object.c</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Livrable3 Informatique Phelma SICOM
   </div>
   <div id="projectbrief">Interpréteur Scheme</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Généré par Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Recherche');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Page&#160;principale</span></a></li>
      <li><a href="pages.html"><span>Pages&#160;associées</span></a></li>
      <li><a href="annotated.html"><span>Structures&#160;de&#160;données</span></a></li>
      <li class="current"><a href="files.html"><span>Fichiers</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Recherche" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>Liste&#160;des&#160;fichiers</span></a></li>
      <li><a href="globals.html"><span>Variables&#160;globale</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Fonctions</a>  </div>
  <div class="headertitle">
<div class="title">Référence du fichier object.c</div>  </div>
</div><!--header-->
<div class="contents">

<p>Fonctions relatives à la structure object.  
<a href="#details">Plus de détails...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="object_8h_source.html">object.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Graphe des dépendances par inclusion de object.c:</div>
<div class="dyncontent">
<div class="center"><img src="object_8c__incl.png" border="0" usemap="#src_2object_8c" alt=""/></div>
<!-- MAP 0 -->
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Fonctions</h2></td></tr>
<tr class="memitem:ae588b0336388f82cf984bca34a66fe99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structobject__t.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#ae588b0336388f82cf984bca34a66fe99">make_object</a> (uint type)</td></tr>
<tr class="memdesc:ae588b0336388f82cf984bca34a66fe99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alloue un objet de type type, vérifie l'alloc.  <a href="#ae588b0336388f82cf984bca34a66fe99">Plus de détails...</a><br /></td></tr>
<tr class="separator:ae588b0336388f82cf984bca34a66fe99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0175150d600f632a2675d80b72823f45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structobject__t.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#a0175150d600f632a2675d80b72823f45">make_nil</a> (void)</td></tr>
<tr class="memdesc:a0175150d600f632a2675d80b72823f45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alloue l'objet nil qui marque fin de o. Programme se termine si l'alloc rate.  <a href="#a0175150d600f632a2675d80b72823f45">Plus de détails...</a><br /></td></tr>
<tr class="separator:a0175150d600f632a2675d80b72823f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa54a323be37760f91b9a423760d800d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structobject__t.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#aa54a323be37760f91b9a423760d800d3">make_true</a> (void)</td></tr>
<tr class="memdesc:aa54a323be37760f91b9a423760d800d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Créé le booléen vrai (variable globale). Fonction appelée dans <a class="el" href="repl_8c.html#ac7892fa748bffcd6854f8b7adeb40ba0" title="Initialise les variables globales de l&#39;interpréteur. ">init_interpreter()</a>.  <a href="#aa54a323be37760f91b9a423760d800d3">Plus de détails...</a><br /></td></tr>
<tr class="separator:aa54a323be37760f91b9a423760d800d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c208c0fbec6ecf85e3de7949b7691cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structobject__t.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#a0c208c0fbec6ecf85e3de7949b7691cf">make_false</a> (void)</td></tr>
<tr class="memdesc:a0c208c0fbec6ecf85e3de7949b7691cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Créé le booléen faux (variable globale). Fonction appelée dans <a class="el" href="repl_8c.html#ac7892fa748bffcd6854f8b7adeb40ba0" title="Initialise les variables globales de l&#39;interpréteur. ">init_interpreter()</a>.  <a href="#a0c208c0fbec6ecf85e3de7949b7691cf">Plus de détails...</a><br /></td></tr>
<tr class="separator:a0c208c0fbec6ecf85e3de7949b7691cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabab05a704acf24c0040b7223908c858"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#aabab05a704acf24c0040b7223908c858">make_forms</a> ()</td></tr>
<tr class="memdesc:aabab05a704acf24c0040b7223908c858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise formes de l'interpréteur.  <a href="#aabab05a704acf24c0040b7223908c858">Plus de détails...</a><br /></td></tr>
<tr class="separator:aabab05a704acf24c0040b7223908c858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421310d9e2d05d70789086bd9418656c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#a421310d9e2d05d70789086bd9418656c">OBJECT_set_cxr</a> (<a class="el" href="structobject__t.html">object</a> o, <a class="el" href="structobject__t.html">object</a> val, char *place)</td></tr>
<tr class="memdesc:a421310d9e2d05d70789086bd9418656c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifie l'emplacement donné et y met la variable val.  <a href="#a421310d9e2d05d70789086bd9418656c">Plus de détails...</a><br /></td></tr>
<tr class="separator:a421310d9e2d05d70789086bd9418656c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d4c460873067cf00d877f60cdd285ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#a4d4c460873067cf00d877f60cdd285ec">OBJECT_set_cdr</a> (<a class="el" href="structobject__t.html">object</a> o, <a class="el" href="structobject__t.html">object</a> cdr)</td></tr>
<tr class="memdesc:a4d4c460873067cf00d877f60cdd285ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Met à jour le cdr de o avec l'object cdr.  <a href="#a4d4c460873067cf00d877f60cdd285ec">Plus de détails...</a><br /></td></tr>
<tr class="separator:a4d4c460873067cf00d877f60cdd285ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ccb3f30397a60a9d663f43c4dc28514"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#a8ccb3f30397a60a9d663f43c4dc28514">OBJECT_set_car</a> (<a class="el" href="structobject__t.html">object</a> o, <a class="el" href="structobject__t.html">object</a> car)</td></tr>
<tr class="memdesc:a8ccb3f30397a60a9d663f43c4dc28514"><td class="mdescLeft">&#160;</td><td class="mdescRight">Met à jour le car de o avec l'objet car.  <a href="#a8ccb3f30397a60a9d663f43c4dc28514">Plus de détails...</a><br /></td></tr>
<tr class="separator:a8ccb3f30397a60a9d663f43c4dc28514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade583a8335577c269af8b9cc37567699"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structobject__t.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#ade583a8335577c269af8b9cc37567699">OBJECT_build_pair</a> (<a class="el" href="structobject__t.html">object</a> car, <a class="el" href="structobject__t.html">object</a> cdr)</td></tr>
<tr class="memdesc:ade583a8335577c269af8b9cc37567699"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construit une paire avec un car et cdr donné.  <a href="#ade583a8335577c269af8b9cc37567699">Plus de détails...</a><br /></td></tr>
<tr class="separator:ade583a8335577c269af8b9cc37567699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba2f19194908157a74d7250b28929484"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structobject__t.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#aba2f19194908157a74d7250b28929484">OBJECT_build_symbol</a> (char *symbol)</td></tr>
<tr class="memdesc:aba2f19194908157a74d7250b28929484"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construit un object de type symbole contenant symbole.  <a href="#aba2f19194908157a74d7250b28929484">Plus de détails...</a><br /></td></tr>
<tr class="separator:aba2f19194908157a74d7250b28929484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09933fca31b4b68d1e8d1d8f26f7ce45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structobject__t.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#a09933fca31b4b68d1e8d1d8f26f7ce45">OBJECT_build_cpy</a> (<a class="el" href="structobject__t.html">object</a> o)</td></tr>
<tr class="memdesc:a09933fca31b4b68d1e8d1d8f26f7ce45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copie l'objet o en en allouant un nouveau.  <a href="#a09933fca31b4b68d1e8d1d8f26f7ce45">Plus de détails...</a><br /></td></tr>
<tr class="separator:a09933fca31b4b68d1e8d1d8f26f7ce45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f88c49537b92e95b7d33660446ee8c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#a5f88c49537b92e95b7d33660446ee8c7">OBJECT_destroy</a> (<a class="el" href="structobject__t.html">object</a> *o)</td></tr>
<tr class="memdesc:a5f88c49537b92e95b7d33660446ee8c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supprime un objet.  <a href="#a5f88c49537b92e95b7d33660446ee8c7">Plus de détails...</a><br /></td></tr>
<tr class="separator:a5f88c49537b92e95b7d33660446ee8c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1356f35f47fdbb828bc06a5884d74ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#ad1356f35f47fdbb828bc06a5884d74ed">OBJECT_destroy_pair</a> (<a class="el" href="structobject__t.html">object</a> *o)</td></tr>
<tr class="memdesc:ad1356f35f47fdbb828bc06a5884d74ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supprime une paire. Fonction récursive.  <a href="#ad1356f35f47fdbb828bc06a5884d74ed">Plus de détails...</a><br /></td></tr>
<tr class="separator:ad1356f35f47fdbb828bc06a5884d74ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d783570ac14dc2efa3f0565e162a6e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structobject__t.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#a1d783570ac14dc2efa3f0565e162a6e8">OBJECT_built_short_quote</a> (char *input, uint *here)</td></tr>
<tr class="memdesc:a1d783570ac14dc2efa3f0565e162a6e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construit le début de pair pour quote sous forme '.  <a href="#a1d783570ac14dc2efa3f0565e162a6e8">Plus de détails...</a><br /></td></tr>
<tr class="separator:a1d783570ac14dc2efa3f0565e162a6e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d7084a07b321423f9cd922529fd8ed8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#a0d7084a07b321423f9cd922529fd8ed8">OBJECT_isempty</a> (<a class="el" href="structobject__t.html">object</a> o)</td></tr>
<tr class="memdesc:a0d7084a07b321423f9cd922529fd8ed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vérifie si un objet est vide (égal à NULL)  <a href="#a0d7084a07b321423f9cd922529fd8ed8">Plus de détails...</a><br /></td></tr>
<tr class="separator:a0d7084a07b321423f9cd922529fd8ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486b361de0c6c18f7227158b12dbfd4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structobject__t.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#a486b361de0c6c18f7227158b12dbfd4a">OBJECT_get_cxr</a> (<a class="el" href="structobject__t.html">object</a> o, char *place)</td></tr>
<tr class="memdesc:a486b361de0c6c18f7227158b12dbfd4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renvoie de l'élement de la pair correspondant à la chaine.  <a href="#a486b361de0c6c18f7227158b12dbfd4a">Plus de détails...</a><br /></td></tr>
<tr class="separator:a486b361de0c6c18f7227158b12dbfd4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64f2fee85ada6041d0c74a250c419686"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#a64f2fee85ada6041d0c74a250c419686">OBJECT_rewrite</a> (<a class="el" href="structobject__t.html">object</a> changed, <a class="el" href="structobject__t.html">object</a> nouveau)</td></tr>
<tr class="memdesc:a64f2fee85ada6041d0c74a250c419686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Réécris avec la valeur de nouveau.  <a href="#a64f2fee85ada6041d0c74a250c419686">Plus de détails...</a><br /></td></tr>
<tr class="separator:a64f2fee85ada6041d0c74a250c419686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab49b1649bad38a97c44b7713731cea48"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#ab49b1649bad38a97c44b7713731cea48">OBJECT_isEqual</a> (<a class="el" href="structobject__t.html">object</a> a, <a class="el" href="structobject__t.html">object</a> b)</td></tr>
<tr class="memdesc:ab49b1649bad38a97c44b7713731cea48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare deux object Renvoie 1 s'ils sont égaux 0 sinon.  <a href="#ab49b1649bad38a97c44b7713731cea48">Plus de détails...</a><br /></td></tr>
<tr class="separator:ab49b1649bad38a97c44b7713731cea48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8467e456f150c3514808c26c6864497d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#a8467e456f150c3514808c26c6864497d">OBJECT_cmp_bool</a> (<a class="el" href="structobject__t.html">object</a> a, <a class="el" href="structobject__t.html">object</a> b)</td></tr>
<tr class="memdesc:a8467e456f150c3514808c26c6864497d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare 2 booléens. Renvoie 0 s'ils ne sont pas booléens.  <a href="#a8467e456f150c3514808c26c6864497d">Plus de détails...</a><br /></td></tr>
<tr class="separator:a8467e456f150c3514808c26c6864497d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a7c4f6341e5477c8cf12d9fa4b8048"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#aa8a7c4f6341e5477c8cf12d9fa4b8048">OBJECT_cmp_number</a> (<a class="el" href="structobject__t.html">object</a> a, <a class="el" href="structobject__t.html">object</a> b)</td></tr>
<tr class="memdesc:aa8a7c4f6341e5477c8cf12d9fa4b8048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare deux objets de type entier.  <a href="#aa8a7c4f6341e5477c8cf12d9fa4b8048">Plus de détails...</a><br /></td></tr>
<tr class="separator:aa8a7c4f6341e5477c8cf12d9fa4b8048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b5035114247cba825eafb2ef1d34c0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#a85b5035114247cba825eafb2ef1d34c0">OBJECT_cmp_symb</a> (<a class="el" href="structobject__t.html">object</a> a, char *symbol)</td></tr>
<tr class="memdesc:a85b5035114247cba825eafb2ef1d34c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a avec le symbol symbol.  <a href="#a85b5035114247cba825eafb2ef1d34c0">Plus de détails...</a><br /></td></tr>
<tr class="separator:a85b5035114247cba825eafb2ef1d34c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79151b36db8756df298be886a88dde6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structobject__t.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#a79151b36db8756df298be886a88dde6a">OBJECT_add</a> (const <a class="el" href="structobject__t.html">object</a> a, const <a class="el" href="structobject__t.html">object</a> b, <a class="el" href="structobject__t.html">object</a> result)</td></tr>
<tr class="memdesc:a79151b36db8756df298be886a88dde6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Effectue la somme de 2 objets, écrit résultat dans résult.  <a href="#a79151b36db8756df298be886a88dde6a">Plus de détails...</a><br /></td></tr>
<tr class="separator:a79151b36db8756df298be886a88dde6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457357b9ad319b66d3573aaeb2d77933"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#a457357b9ad319b66d3573aaeb2d77933">check_alloc</a> (void *ptr, char *message)</td></tr>
<tr class="memdesc:a457357b9ad319b66d3573aaeb2d77933"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vérifie une allocation dynamique.  <a href="#a457357b9ad319b66d3573aaeb2d77933">Plus de détails...</a><br /></td></tr>
<tr class="separator:a457357b9ad319b66d3573aaeb2d77933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa57b70a35593ee0e9483282f796a5122"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#aa57b70a35593ee0e9483282f796a5122">check_type</a> (<a class="el" href="structobject__t.html">object</a> o, int sfs_type)</td></tr>
<tr class="memdesc:aa57b70a35593ee0e9483282f796a5122"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vérifie que o est bien de type sfs_type.  <a href="#aa57b70a35593ee0e9483282f796a5122">Plus de détails...</a><br /></td></tr>
<tr class="separator:aa57b70a35593ee0e9483282f796a5122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae40aea5d87d9c145bfe576adb9a93f10"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#ae40aea5d87d9c145bfe576adb9a93f10">string_cmp</a> (char *a, char *b)</td></tr>
<tr class="memdesc:ae40aea5d87d9c145bfe576adb9a93f10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare chaine a et b. Renvoie 1 si égale 0 sinon.  <a href="#ae40aea5d87d9c145bfe576adb9a93f10">Plus de détails...</a><br /></td></tr>
<tr class="separator:ae40aea5d87d9c145bfe576adb9a93f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54510b61c6f3490e0d71cbc71cc4225a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#a54510b61c6f3490e0d71cbc71cc4225a">is_form</a> (<a class="el" href="structobject__t.html">object</a> symbol, FORMS *forme)</td></tr>
<tr class="memdesc:a54510b61c6f3490e0d71cbc71cc4225a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renvoie 1 si symbol est un mot clef du langage scheme.  <a href="#a54510b61c6f3490e0d71cbc71cc4225a">Plus de détails...</a><br /></td></tr>
<tr class="separator:a54510b61c6f3490e0d71cbc71cc4225a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8d164b8e7142d98aaff83ccfcd48409"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#aa8d164b8e7142d98aaff83ccfcd48409">check</a> (void *ptr, char *message)</td></tr>
<tr class="memdesc:aa8d164b8e7142d98aaff83ccfcd48409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Si ptr est NULL affiche message dans un warning.  <a href="#aa8d164b8e7142d98aaff83ccfcd48409">Plus de détails...</a><br /></td></tr>
<tr class="separator:aa8d164b8e7142d98aaff83ccfcd48409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe65b3e6071e628e9dd27ceb779a253"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#a0fe65b3e6071e628e9dd27ceb779a253">isealnum</a> (char c)</td></tr>
<tr class="memdesc:a0fe65b3e6071e628e9dd27ceb779a253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vérifie si c est un caractère compatible pour une expression scheme (voir R5RS)  <a href="#a0fe65b3e6071e628e9dd27ceb779a253">Plus de détails...</a><br /></td></tr>
<tr class="separator:a0fe65b3e6071e628e9dd27ceb779a253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8db21bf1c03bc99e813b38a77ff8792e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#a8db21bf1c03bc99e813b38a77ff8792e">wait_first_non_blank_char</a> (char *s1, uint *s1_cursor)</td></tr>
<tr class="memdesc:a8db21bf1c03bc99e813b38a77ff8792e"><td class="mdescLeft">&#160;</td><td class="mdescRight">incrémente le curseur tant qu'il y indique un espace dans la chaine  <a href="#a8db21bf1c03bc99e813b38a77ff8792e">Plus de détails...</a><br /></td></tr>
<tr class="separator:a8db21bf1c03bc99e813b38a77ff8792e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13394f7830becff1f3558b6f5b0969f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structobject__t.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#a13394f7830becff1f3558b6f5b0969f9">ENV_build</a> (<a class="el" href="structobject__t.html">object</a> father)</td></tr>
<tr class="memdesc:a13394f7830becff1f3558b6f5b0969f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construit un environnement dont le père est father.  <a href="#a13394f7830becff1f3558b6f5b0969f9">Plus de détails...</a><br /></td></tr>
<tr class="separator:a13394f7830becff1f3558b6f5b0969f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c450315c9bb5fc8d72fe422bccad428"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structobject__t.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#a6c450315c9bb5fc8d72fe422bccad428">ENV_get_var_in_env</a> (<a class="el" href="structobject__t.html">object</a> var, <a class="el" href="structobject__t.html">object</a> environ, int *flag)</td></tr>
<tr class="memdesc:a6c450315c9bb5fc8d72fe422bccad428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chercher la variable de nom var dans l'environnement environ.  <a href="#a6c450315c9bb5fc8d72fe422bccad428">Plus de détails...</a><br /></td></tr>
<tr class="separator:a6c450315c9bb5fc8d72fe422bccad428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9408de05ed658e0c2b39b06dfa52afc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structobject__t.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#a9408de05ed658e0c2b39b06dfa52afc9">ENV_get_var</a> (<a class="el" href="structobject__t.html">object</a> var, int *flag)</td></tr>
<tr class="memdesc:a9408de05ed658e0c2b39b06dfa52afc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cherche le symbole var dans les environnements.  <a href="#a9408de05ed658e0c2b39b06dfa52afc9">Plus de détails...</a><br /></td></tr>
<tr class="separator:a9408de05ed658e0c2b39b06dfa52afc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad94ca4613c4d0f6214c77363f55008f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structobject__t.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#aad94ca4613c4d0f6214c77363f55008f">ENV_add_var</a> (<a class="el" href="structobject__t.html">object</a> name, <a class="el" href="structobject__t.html">object</a> value)</td></tr>
<tr class="memdesc:aad94ca4613c4d0f6214c77363f55008f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ajoute la variable de nom name et de valeur value l'environnement courant.  <a href="#aad94ca4613c4d0f6214c77363f55008f">Plus de détails...</a><br /></td></tr>
<tr class="separator:aad94ca4613c4d0f6214c77363f55008f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a700e3a4614699deb08c3640cd18af8e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structobject__t.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#a700e3a4614699deb08c3640cd18af8e3">ENV_update_var</a> (<a class="el" href="structobject__t.html">object</a> name, const <a class="el" href="structobject__t.html">object</a> val, int mode, int *free_flag)</td></tr>
<tr class="memdesc:a700e3a4614699deb08c3640cd18af8e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mets à jour la variable de nom name à la valeur val.  <a href="#a700e3a4614699deb08c3640cd18af8e3">Plus de détails...</a><br /></td></tr>
<tr class="separator:a700e3a4614699deb08c3640cd18af8e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fb587a2ac0a4bebac5317ece2968594"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8c.html#a7fb587a2ac0a4bebac5317ece2968594">ENV_check_loop</a> (<a class="el" href="structobject__t.html">object</a> name)</td></tr>
<tr class="memdesc:a7fb587a2ac0a4bebac5317ece2968594"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vérifie la validité d'un environnement.  <a href="#a7fb587a2ac0a4bebac5317ece2968594">Plus de détails...</a><br /></td></tr>
<tr class="separator:a7fb587a2ac0a4bebac5317ece2968594"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Description détaillée</h2>
<div class="textblock"><p>Fonctions relatives à la structure object. </p>
<dl class="section author"><dt>Auteur</dt><dd>François Cayre &lt;cayre.(null)&gt; and Rimbaud Sébastien <a href="#" onclick="location.href='mai'+'lto:'+'seb'+'as'+'tie'+'n.'+'rim'+'ba'+'ud@'+'ph'+'elm'+'a.'+'gre'+'no'+'ble'+'-i'+'np.'+'fr'; return false;">sebas<span style="display: none;">.nosp@m.</span>tien<span style="display: none;">.nosp@m.</span>.rimb<span style="display: none;">.nosp@m.</span>aud@<span style="display: none;">.nosp@m.</span>phelm<span style="display: none;">.nosp@m.</span>a.gr<span style="display: none;">.nosp@m.</span>enobl<span style="display: none;">.nosp@m.</span>e-in<span style="display: none;">.nosp@m.</span>p.fr</a> </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Sun September 2016 16:35 Contient toutes les fonctions permettant de manipuler (affichage, édition) de la structure object. Contient également les fonctions de création de NIL, TRUE et FALSE. </dd></dl>
</div><h2 class="groupheader">Documentation des fonctions</h2>
<a class="anchor" id="aa8d164b8e7142d98aaff83ccfcd48409"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int check </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Si ptr est NULL affiche message dans un warning. </p>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie 0 si ptr==NULL </dd></dl>

</div>
</div>
<a class="anchor" id="a457357b9ad319b66d3573aaeb2d77933"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void check_alloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vérifie une allocation dynamique. </p>
<p>Quitte le programme avec un ERROR_MSG si une alloc rate. </p>

</div>
</div>
<a class="anchor" id="aa57b70a35593ee0e9483282f796a5122"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int check_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sfs_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vérifie que o est bien de type sfs_type. </p>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie 1 si o est de type sfs_type, 0 sinon. Renvoie 0 si o de type SFS_UNKNOW quelque soit sfs_type. </dd></dl>

</div>
</div>
<a class="anchor" id="aad94ca4613c4d0f6214c77363f55008f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structobject__t.html">object</a> ENV_add_var </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ajoute la variable de nom name et de valeur value l'environnement courant. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>: Nom de la variable (symbole) </td></tr>
    <tr><td class="paramname">value</td><td>: valeur de la variable.</td></tr>
  </table>
  </dd>
</dl>
<p>Ajoute la variable de nom name et de valeur value à l'environnement courant. Si jamais elle existe déjà la variable est écrasée et reçoit une nouvelle valeur. Renvoie name et affiche un warning si name n'est pas un symbole. Renvoie value et affiche un warning si value est de type SFS_ENV. Dans les 2 précédents cas quitte la fonction prématurément sans effectuer d'actions.</p>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie la valeur de la variable crée. </dd></dl>

</div>
</div>
<a class="anchor" id="a13394f7830becff1f3558b6f5b0969f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structobject__t.html">object</a> ENV_build </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>father</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construit un environnement dont le père est father. </p>
<p>L'environnement construit possède comme parent father. Si father est mis à nul, construit un top-level.</p>
<dl class="section return"><dt>Renvoie</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a7fb587a2ac0a4bebac5317ece2968594"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ENV_check_loop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vérifie la validité d'un environnement. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>: Variable que l'on souhaite vérifier.</td></tr>
  </table>
  </dd>
</dl>
<p>Vérifie qu'un environnement en présente pas d'incohérences comme des appels circulaires de variable :<br />
x-&gt;y-&gt;z-&gt;x-&gt;y... .</p>
<dl class="section return"><dt>Renvoie</dt><dd>0 si incohérences trouvées, 1 sinon. </dd></dl>

</div>
</div>
<a class="anchor" id="a9408de05ed658e0c2b39b06dfa52afc9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structobject__t.html">object</a> ENV_get_var </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cherche le symbole var dans les environnements. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">var</td><td>: Symbole à chercher.  flat : Drapeau pour savoir s'il est trouvé. Mis à 1 si trouvé.</td></tr>
  </table>
  </dd>
</dl>
<p>Cherche la variable var dans les environnements. Si var n'est pas un symbole cette fonction affiche un warning et renvoie var. Retourne la première occurrence de le variable dans l'environnement courant. Si elle n'est pas trouvée il cherche dans les pères jusqu'à trouver la première occurrence de la variable. Si jamais il ne la trouve pas il renvoie NULL. S'il trouve le symbole le flag est mis à 1.</p>
<dl class="section see"><dt>Voir également</dt><dd><a class="el" href="object_8c.html#a6c450315c9bb5fc8d72fe422bccad428" title="Chercher la variable de nom var dans l&#39;environnement environ. ">ENV_get_var_in_env</a></dd></dl>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie une paire dont le car porte le nom de la variable et le cdr sa valeur. </dd></dl>

</div>
</div>
<a class="anchor" id="a6c450315c9bb5fc8d72fe422bccad428"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structobject__t.html">object</a> ENV_get_var_in_env </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>environ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Chercher la variable de nom var dans l'environnement environ. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">var</td><td>: Nom de la variable que l'on cherche. </td></tr>
    <tr><td class="paramname">environ</td><td>: Environnement dans lequel on cherche </td></tr>
    <tr><td class="paramname">flag</td><td>: Mis à vrai si on a trouvé. Retourne la première occurrence de le variable dans l'environnement courant. Renvoie une pair dont le car porte le nom de la variable et le cdr porte sa valeur. Si jamais il ne la trouve pas il passe le flag à false. S'il trouve il le met à TRUE.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie une paire dont le car porte le nom de la variable (symbole) et le cdr sa valeur. </dd></dl>

</div>
</div>
<a class="anchor" id="a700e3a4614699deb08c3640cd18af8e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structobject__t.html">object</a> ENV_update_var </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>free_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mets à jour la variable de nom name à la valeur val. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>: Symbole à modifier. </td></tr>
    <tr><td class="paramname">val</td><td>: Nouvelle valeur. </td></tr>
    <tr><td class="paramname">mode</td><td>: Mode de modification. </td></tr>
    <tr><td class="paramname">free_flag</td><td>: Flag mis à vrai si on a effectué une suppression.</td></tr>
  </table>
  </dd>
</dl>
<p>Si name n'est pas un symbole affiche un warning et retourne nul. Si val est de type SFS_ENV affiche un warning et retourne nul. Dans les 2 cas il n'y pas d'ajout de variable.</p>
<p>Le flag free_flag est mis à vrai si la fonction appelle OBJECT_destroy. Dans ce cas la valeur associé au symbole name est supprimée. Si elle est associée à un autre symbole celui-ci perd également sa valeur, ainsi le drapeau le signal. De ce fait il faut toujours donner une copie de la valeur à ajouter et non la valeur elle même ainsi un symbole n'est associé qu'à une seule structure.</p>
<p>La valeur initiale du drapeau importe peu, il est mis à faux automatiquement au début de la fonction.</p>
<dl class="section see"><dt>Voir également</dt><dd><a class="el" href="object_8h.html#ad6ae71669c1596ca1e441c7da58c3655">ENV_DISABLE_CREATION</a> </dd>
<dd>
<a class="el" href="object_8h.html#a4e8777591d506b4f54d8c4ff94cdf2a3">ENV_ENABLE_CREATION</a> </dd></dl>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie name. </dd></dl>

</div>
</div>
<a class="anchor" id="a54510b61c6f3490e0d71cbc71cc4225a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int is_form </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>symbol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FORMS *&#160;</td>
          <td class="paramname"><em>forme</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renvoie 1 si symbol est un mot clef du langage scheme. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">symbol</td><td>: Le symbole dont on veut savoir si c'est une forme. </td></tr>
    <tr><td class="paramname">forme</td><td>: Pointeur qui est met à jour pour connaitre la forme dans la variable globale form[].</td></tr>
  </table>
  </dd>
</dl>
<p>Vérifie si symbol est un mot clef du langage. Met à jour forme sur le bon numéro de la forme. Renvoie 1 si c'est le cas 0 sinon. Peut recevoir forme égale à NULL.</p>
<dl class="section see"><dt>Voir également</dt><dd><a class="el" href="object_8c.html#aabab05a704acf24c0040b7223908c858" title="Initialise formes de l&#39;interpréteur. ">make_forms()</a> </dd>
<dd>
NB_FORMS</dd></dl>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie 1 si c'est une forme, 0 sinon. </dd></dl>

</div>
</div>
<a class="anchor" id="a0fe65b3e6071e628e9dd27ceb779a253"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int isealnum </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vérifie si c est un caractère compatible pour une expression scheme (voir R5RS) </p>
<p>Les caractères compatibles sont [a-z] [A-Z] [0-9] et ! $ * = + - . / : &lt; &gt; ? @ &amp; % : ^ _ ~.</p>
<dl class="section see"><dt>Voir également</dt><dd><a href="https://linux.die.net/man/3/isalnum ">isalnum </a> </dd></dl>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie 1 si c est compatible 0 sinon. </dd></dl>

</div>
</div>
<a class="anchor" id="a0c208c0fbec6ecf85e3de7949b7691cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structobject__t.html">object</a> make_false </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Créé le booléen faux (variable globale). Fonction appelée dans <a class="el" href="repl_8c.html#ac7892fa748bffcd6854f8b7adeb40ba0" title="Initialise les variables globales de l&#39;interpréteur. ">init_interpreter()</a>. </p>
<p>Cette fonction quitte l'interpréteur si l'allocation échoue. Inutile de continuer si le booléen n'existe pas dans l'interpréteur. L'objet vrai est de type SFS_BOOLEAN et possède son this.number mis à 0. </p>

</div>
</div>
<a class="anchor" id="aabab05a704acf24c0040b7223908c858"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void make_forms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise formes de l'interpréteur. </p>
<dl class="section see"><dt>Voir également</dt><dd>FORMS; </dd></dl>

</div>
</div>
<a class="anchor" id="a0175150d600f632a2675d80b72823f45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structobject__t.html">object</a> make_nil </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alloue l'objet nil qui marque fin de o. Programme se termine si l'alloc rate. </p>
<p>Le programme se termine si la création de l'objet nil rate. En effet cet objet étant utilisé pour toutes <br />
les listes scheme, un échec de sa création empêchera inévitablement le bon fonctionnement de l'interpréteur.</p>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie un pointeur sur l'objet créé. </dd></dl>

</div>
</div>
<a class="anchor" id="ae588b0336388f82cf984bca34a66fe99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structobject__t.html">object</a> make_object </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alloue un objet de type type, vérifie l'alloc. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>: type de l'objet (num, char, string , string (symbol), PAIR, special (nil)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie un pointeur sur l'objet créé. </dd></dl>

</div>
</div>
<a class="anchor" id="aa54a323be37760f91b9a423760d800d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structobject__t.html">object</a> make_true </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Créé le booléen vrai (variable globale). Fonction appelée dans <a class="el" href="repl_8c.html#ac7892fa748bffcd6854f8b7adeb40ba0" title="Initialise les variables globales de l&#39;interpréteur. ">init_interpreter()</a>. </p>
<p>Cette fonction quitte l'interpréteur si l'allocation échoue. Inutile de continuer si le booléen n'existe pas dans l'interpréteur. L'objet vrai est de type SFS_BOOLEAN et possède son this.number mis à 1. </p>

</div>
</div>
<a class="anchor" id="a79151b36db8756df298be886a88dde6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structobject__t.html">object</a> OBJECT_add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Effectue la somme de 2 objets, écrit résultat dans résult. </p>
<p>La somme est faite sur des objects de type SFS_NUM. Le résultat est écrit dans result et result est retourné. Il faut toujours prendre la valeur retournée par la fonction, result permet d'éviter un trop grand nombre d'allocation dans PRIM_somme. Retourne nil si la somme est irréalisable (Utile pour les affectations).</p>
<dl class="section see"><dt>Voir également</dt><dd>NUM_sum(num a, num b)</dd></dl>
<dl class="section return"><dt>Renvoie</dt><dd>Retourne le résultat de la somme ou nil si erreur. </dd></dl>

</div>
</div>
<a class="anchor" id="a09933fca31b4b68d1e8d1d8f26f7ce45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structobject__t.html">object</a> OBJECT_build_cpy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copie l'objet o en en allouant un nouveau. </p>
<p>Si l'objet est nil ou un booléen on ne refait pas d'alloc on renvoie la variable globale correspondante. Si l'objet est NULL renvoie null et affiche un warning.</p>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie l'objet créé. </dd></dl>

</div>
</div>
<a class="anchor" id="ade583a8335577c269af8b9cc37567699"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structobject__t.html">object</a> OBJECT_build_pair </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>car</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>cdr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construit une paire avec un car et cdr donné. </p>
<p>Construit une liste avec un car et cdr donné. Si car ou cdr == NULL alors il seront mis à nil.</p>
<dl class="section see"><dt>Voir également</dt><dd><a class="el" href="object_8c.html#a4d4c460873067cf00d877f60cdd285ec" title="Met à jour le cdr de o avec l&#39;object cdr. ">OBJECT_set_cdr(object o, object car)</a> </dd>
<dd>
<a class="el" href="object_8c.html#a8ccb3f30397a60a9d663f43c4dc28514" title="Met à jour le car de o avec l&#39;objet car. ">OBJECT_set_car(object o, object car)</a></dd></dl>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie un object avec car et le cdr donné. </dd></dl>

</div>
</div>
<a class="anchor" id="aba2f19194908157a74d7250b28929484"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structobject__t.html">object</a> OBJECT_build_symbol </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>symbol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construit un object de type symbole contenant symbole. </p>
<p>Doit contenir 256 caractère définit pas string et STRLEN.</p>
<dl class="section return"><dt>Renvoie</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a1d783570ac14dc2efa3f0565e162a6e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structobject__t.html">object</a> OBJECT_built_short_quote </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>here</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construit le début de pair pour quote sous forme '. </p>
<p>Lorsque que l'on a '(objects) cette fonction construit l'object équivalent à (quote (object)) Elle appelle sfs_read sur le reste de la liste.</p>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie une forme quote. </dd></dl>

</div>
</div>
<a class="anchor" id="a8467e456f150c3514808c26c6864497d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OBJECT_cmp_bool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare 2 booléens. Renvoie 0 s'ils ne sont pas booléens. </p>
<dl class="section return"><dt>Renvoie</dt><dd>1 si les 2 booléens sont égaux, 0 sinon. </dd></dl>

</div>
</div>
<a class="anchor" id="aa8a7c4f6341e5477c8cf12d9fa4b8048"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OBJECT_cmp_number </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare deux objets de type entier. </p>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie 1 si a et b contiennent les mêmes entiers. 0 sinon. </dd></dl>

</div>
</div>
<a class="anchor" id="a85b5035114247cba825eafb2ef1d34c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OBJECT_cmp_symb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>symbol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare a avec le symbol symbol. </p>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie 1 si égaux, O sinon. </dd></dl>

</div>
</div>
<a class="anchor" id="a5f88c49537b92e95b7d33660446ee8c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OBJECT_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a> *&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supprime un objet. </p>
<p>Supprime tous les éléments d'un objet si c'est une paire, de même pour un environnement. <br />
Fonction a modifier si on alloue dynamiquement les string et symboles. Pour l'instant c'est un free classique. Voir le pb sur les booléens aussi. </p>

</div>
</div>
<a class="anchor" id="ad1356f35f47fdbb828bc06a5884d74ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OBJECT_destroy_pair </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a> *&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supprime une paire. Fonction récursive. </p>
<p>Pas de controle sur o pour savoir si c'est bien une paire. Fonction appelée par OBJECT_destroy. N'utiliser que OBJECT_destroy pas celle-ci, elle n'est utile qu'à l'implémentation du destructeur général. </p>

</div>
</div>
<a class="anchor" id="a486b361de0c6c18f7227158b12dbfd4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structobject__t.html">object</a> OBJECT_get_cxr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>place</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renvoie de l'élement de la pair correspondant à la chaine. </p>
<p>Renvoie l'élément car si la chaine "car" est donnée. Renvoie l'élément cdr si la chaine "cdr" est donnée. Renvoie le car du cdr si la chaine "cadr" est donnée. Lis la chaine à l'envers et prend le cdr si d est donné ou le car si a est donnée. Le format d'entré doit contenir en première lettre un c en dernière un r. En pratique si d'autres lettres sont placées la fonction ne fera pas la différence car elle les ignore. Au milieu on aura que des a et des d. Si on trouve une autre lettre affiche un warning et retourne NULL. Si on spécifie une location inexistante dans la paire la fonction affiche un warning et renvoie NULL. Si o n'est pas une paire, revoie NULL.</p>
<dl class="section return"><dt>Renvoie</dt><dd>Renvoie l'objet lu correspondant à la chaine. </dd></dl>

</div>
</div>
<a class="anchor" id="a0d7084a07b321423f9cd922529fd8ed8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OBJECT_isempty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vérifie si un objet est vide (égal à NULL) </p>
<dl class="section return"><dt>Renvoie</dt><dd>Vrai si vide, faux sinon. </dd></dl>

</div>
</div>
<a class="anchor" id="ab49b1649bad38a97c44b7713731cea48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OBJECT_isEqual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare deux object Renvoie 1 s'ils sont égaux 0 sinon. </p>
<p>Deux objets sont considérés comme égaux s'ils ont le même type et la même valeur. COMPARAISON DE PAIRE NON IMPLEMENTEE.</p>
<dl class="section return"><dt>Renvoie</dt><dd>1 si a==b, 0 sinon. </dd></dl>

</div>
</div>
<a class="anchor" id="a64f2fee85ada6041d0c74a250c419686"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OBJECT_rewrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>changed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>nouveau</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Réécris avec la valeur de nouveau. </p>
<p>Attention si changed est de type SFS_NIL, un nouvel objet est renvoyé. </p><dl class="bug"><dt><b><a class="el" href="bug.html#_bug000001">Bogue:</a></b></dt><dd>Incomplète</dd></dl>

</div>
</div>
<a class="anchor" id="a8ccb3f30397a60a9d663f43c4dc28514"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OBJECT_set_car </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>car</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Met à jour le car de o avec l'objet car. </p>
<p>Si car est NULL place la variable globale nil. </p>

</div>
</div>
<a class="anchor" id="a4d4c460873067cf00d877f60cdd285ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OBJECT_set_cdr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>cdr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Met à jour le cdr de o avec l'object cdr. </p>
<p>Si cdr est a NULL place la variable globale nil. </p>

</div>
</div>
<a class="anchor" id="a421310d9e2d05d70789086bd9418656c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OBJECT_set_cxr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject__t.html">object</a>&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>place</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modifie l'emplacement donné et y met la variable val. </p>
<p>Cette fonction libère l'ancienne valeur. L'objet à ajouter doit-être préalablement alloué. Ne fait rien si o est a NULL. Ajoute nil si val est a NULL avec un appel récursif.</p>
<dl class="section see"><dt>Voir également</dt><dd><a class="el" href="object_8c.html#a5f88c49537b92e95b7d33660446ee8c7" title="Supprime un objet. ">OBJECT_destroy</a> </dd>
<dd>
<a class="el" href="object_8c.html#a486b361de0c6c18f7227158b12dbfd4a" title="Renvoie de l&#39;élement de la pair correspondant à la chaine. ">OBJECT_get_cxr</a></dd></dl>
<dl class="section return"><dt>Renvoie</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ae40aea5d87d9c145bfe576adb9a93f10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int string_cmp </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare chaine a et b. Renvoie 1 si égale 0 sinon. </p>
<p>Si les chaines n'ont pas la même longueur renvoie 0. Compare les chaines avec strncmp.</p>
<dl class="section return"><dt>Renvoie</dt><dd>1 si chaine égales, 0 sinon. </dd></dl>

</div>
</div>
<a class="anchor" id="a8db21bf1c03bc99e813b38a77ff8792e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wait_first_non_blank_char </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>s1_cursor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>incrémente le curseur tant qu'il y indique un espace dans la chaine </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>: Chaine dans laquelle on veut sauter les espaces. </td></tr>
    <tr><td class="paramname">s1_cursor</td><td>: Curseur dans la chaine.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>Voir également</dt><dd><a href="https://linux.die.net/man/3/isspace">isspace </a> </dd></dl>
<dl class="section return"><dt>Renvoie</dt><dd>: Renvoie le premier indice qui n'est pas un espace. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Généré par &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
