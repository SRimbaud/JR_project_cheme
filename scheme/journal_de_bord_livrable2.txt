Ajout des fonctions quote et de son abréviation '( ).
Modification du print pour gérer les cas du type :
(())
Livrable 1 retourne :
())
Maintenant :
(())

( () () )
Livrable 1 retourne :
( ) () ) Ou un truc dans l'genre
Maintenant ( () () )
On a ainsi modifier print_pair et print_nil.

Ajout de plusieurs fonctions permettant de modifier le
car et le cdr d'une fonction.

print_atom conserve la capacité d'afficher nil mais affiche un warning si ce
cas se produit en effet il ne doit plus être utilisé pour afficher nil.
Il affichera "()" si jamais il est poussé à afficher nil.

On a également gérer les quote.
(quote (define x 4)) renvoie (defne x 4)
'(define x 4) la même chose

on remarque ''(symbole) renvoie (quote (symbole))
et '('(symbole)) renvoie ((quote (symbole))) ce qui est normal 
vérif faites avec scheme48.

Ajout d'accesseur pour modifier rapidement cdr et car d'une liste.
Si on met null il place automatiquement nil dedans.
Ajout d'un constructeur permettant de créer une pair avec 2 objet distinct.
Fait appel aux accesseurs set.

Structure d'environnement et variables.
-Nous choisissons les conventions suivantes pour les environnements :
-Un environnement est défini par un object.
-Il est de type SFS_ENV.
-Son car pointe son environnement parent.
-Son cdr pointe la liste des variables.
-L'envrionnement est pointé par une variable globale.
-Un environnement dont le parent est NULL est considéré comme top level.

Structure des variables :
-Les variables sont stockées dans des listes.
-Des pairs font le lien entre chaque variable.
-Le car de cette pair pointe la variable.
-Le cdr pointe la variable suivante de l'environnement.

La variable est constitué d'une paire dont :
-Le car correspond au nom de la variable (type SFS_SYMBOLE)
-Le cdr sa valeur (type random)
On va créer des fichiers dédiés à la gestion de l'environnement.
Environnement : ENV.
On aura un ensemble de méthodes stockées dans environnement.h environnement.c

Enorme instabilité sur la fonction OBJECT_destroy, elle change des valeurs
qu'elle ne devrait pas toucher. Je soupçonne free d'ếtre reponsable.
Quand je commente cette fonction tout marche bien.
Je pense que j'ai un problème dans le tas et que free libère tout ce
qu'il y a au dessus du coup je perd ma valeur.
ça pose surtout problème pour la gestion du cas type
(define x 4)
(define x y)
(define y x)
x
==> BOUCLE INFINIIIEEEEE
Va savoir pourquoi.
Ou pour des déclarations de variables circulaires type :
(define x 4)
(define x a)
(define b a)
(define b c)
(define c x)
x
==> BOUCLE INFINIIIIEEEEE.

J'ai trouvé le problème. En réalité lorsque je fais un set! ou define
j'indique comme valeur la valeur qui est lu. Ainsi plusieurs noms
peuvent pointer une même variable.
2 choix alors :
Soit on cherche à savoir quels sont les noms qui pointent cette
valeur.
Soit on réalise des copies (plus de mémoire mais peut-être un peu
plus rapide et surtout plus simple à implémenter)
De ce fait dans l'affectation croisée, lorsque je reboucle et 
que j'efface la variable initiale je supprime la valeur de TOUTES
les variables et donc la copie qui suit rate inévitablement.
Maintenant je fais une copie avant de mettre à jour quoique ce soit.
Dans tous les cas je free ce qui est lu après un affichage.
Je free également la valeur qui vient d'être remplacée.

Correction d'un bug sur la lecture des symboles invalides,
le curseur here ne s'incrémentait pas dans ce cas ce qui amène 
des boucles infinies plus tard.
Maintenant il s'incrémente correctement

Enorme changement dans les fichiers, j'ai limité au maximum
les inclusions croisées ce qui fait que j'ai essayé de regrouper les
fonctions par thématiques.

and et or sont implémentés.
and prend une infinité de paramétres.
Tant qu'il sont vrai il continue à les évaluer, dès qu'il trouve un faux il
renvoie faux.
Si il croise un symbole qui n'est pas un booléen il le considére comme vrai.
(scheme48)

or :
Prend une infinité de variables et tant qu'il croise un booléen faux il
continue à évaluer. Si jamais il croise un vrai il s'arrête et renvoie vrai.
Un symbole non booléen est interprété comme faux.
(scheme 48)
Il ne reste plus qu'à faire if.
